<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.4.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-09-15T16:27:52-07:00</updated><id>http://localhost:4000/</id><title type="html">Aperjump's Playground</title><subtitle>Embrace your inner geek.</subtitle><author><name>Wang Wei</name></author><entry><title type="html">How to debug a multi-thread program</title><link href="http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program/" rel="alternate" type="text/html" title="How to debug a multi-thread program" /><published>2018-09-04T00:00:00-07:00</published><updated>2018-09-04T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program</id><content type="html" xml:base="http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program/">&lt;h2 id=&quot;heading-how-to-debug-a-multi-thread-program&quot;&gt;How to debug a multi-thread program.&lt;/h2&gt;
&lt;p&gt;This passage will discuss the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt; for multi-threading program debug. You can find my code on my github &lt;a href=&quot;https://github.com/Aperjump/blog_code/tree/master/How-to-degbug-A-multithreaded-program&quot;&gt;code&lt;/a&gt;
The code implements a simple producer-consumer pattern written in C, and use &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread&lt;/code&gt; to create new threads. Although you can compile it without any problem, there are four bugs in the code and our mission is to find them all using &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;heading-lldb&quot;&gt;lldb&lt;/h3&gt;
&lt;p&gt;For &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; users, some commands may different, but there is a command transformation &lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot;&gt;table&lt;/a&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;heading-basic-commands&quot;&gt;Basic Commands&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# set breakpoint for xx function
(lldb)breakpoint set -name xx
# set breakpoint for method in class
(lldb)breakpoint set -method xx
# set breakpoint in file F line L
(lldb)breakpoint set -file F -line L
# set breakpoint in function address
(lldb)breakpoint set -a funcaddr
# list all breakpoints
(lldb)breakpoint list
# delete break point
(lldb)breakpoint delete index
------------------------------
# run
(lldb)r
# next
(lldb)n
# step int
(lldb)s
# step out
(lldb)f
# continue
(lldb)c
------------------------------
# watch some variable change when written
(lldb)watchpoint set variable val
------------------------------
# variable in current frame
(lldb)frame variable
(lldb)fr v
# print variable
(lldb)p val
------------------------------
# find all frames
(lldb)thread backtrace all
(lldb)bt all
# current frame
(lldb)thread backtrace
(lldb)bt
# select frame X
(lldb)frame select X
# thread in current frame
(lldb)thread list
# select thread X
(lldb)thread select X
----------------------------
# evaluate a expression E
(lldb)expression E
(lldb)e E
# note expression can be used to dynamically change a value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt; share most commands with &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;. 
Note : Although &lt;code class=&quot;highlighter-rouge&quot;&gt;watchpoint&lt;/code&gt; seems like a powerful tool, it's rather limited. On my MacBook Pro(x86_64), there are only 4 hardware watchpoint registers, each at most 8 bytes. So there can be only 48 byte range support. If you read the code, the most important structure is &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_t&lt;/code&gt;, since it includes one &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_lock&lt;/code&gt;, which is 64 bytes, &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_t&lt;/code&gt; cannot fit in our watchlist registers.&lt;/p&gt;
&lt;h3 id=&quot;heading-program&quot;&gt;program&lt;/h3&gt;
&lt;p&gt;(1) Failed to join producer thread: Invalid argument
If we run the program without any modification, we will get this error. So why does this happen? 
Jumping into the code&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x000000010000178e producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:72
   69     /* Join threads, handle return values where appropriate */
   70
   71     result = pthread_join(producer_thread, NULL);
-&amp;gt; 72     if (0 != result) {
   73       fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result));
   74       pthread_exit(NULL);
   75     }
Target 0: (producer_consumer) stopped.
(lldb) p result
(int) $3 = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Here we can see &lt;code class=&quot;highlighter-rouge&quot;&gt;result=3&lt;/code&gt;, indicates we are trying to join a thread which doesn't exist. If we print &lt;code class=&quot;highlighter-rouge&quot;&gt;g_num_prod&lt;/code&gt;, it returns 1, meaning that our &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt; has not stopped (only producer_routine will change &lt;code class=&quot;highlighter-rouge&quot;&gt;g_num_prod&lt;/code&gt; value).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) bt all
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x000000010000177d producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:71
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
  thread #2
    frame #0: 0x00007fff721f1306 libsystem_kernel.dylib`swtch_pri + 10
    frame #1: 0x00007fff723c322e libsystem_pthread.dylib`sched_yield + 11
    frame #2: 0x0000000100001ae4 producer_consumer`producer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:133
    frame #3: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #4: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #5: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100001c39 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:172
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #4
    frame #0: 0x00007fff721fb2ba libsystem_kernel.dylib`__write_nocancel + 10
    frame #1: 0x00007fff7213c796 libsystem_c.dylib`_swrite + 87
    frame #2: 0x00007fff721353bd libsystem_c.dylib`__sflush + 87
    frame #3: 0x00007fff72137aa8 libsystem_c.dylib`__sfvwrite + 816
    frame #4: 0x00007fff72141738 libsystem_c.dylib`__vfprintf + 16158
    frame #5: 0x00007fff72166059 libsystem_c.dylib`__v2printf + 473
    frame #6: 0x00007fff7213d742 libsystem_c.dylib`vfprintf_l + 54
    frame #7: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #8: 0x0000000100001b4a producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:148
    frame #9: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #10: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #11: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We can see just before &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt; there are still 4 frames. The reason here is the use of &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_detach()&lt;/code&gt; will make a thread cannot join.&lt;/p&gt;

&lt;p&gt;(2) Segment Fault
After the first modification, my program will block at&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) n
Process 64207 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100000846 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:82
   79       fprintf(stderr, &quot;Failed to join consumer thread: %s\n&quot;, strerror(result));
   80       pthread_exit(NULL);
   81     }
-&amp;gt; 82     printf(&quot;\nPrinted %lu characters.\n&quot;, *(long*)thread_return);
   83     free(thread_return);
   84
   85     pthread_mutex_destroy(&amp;amp;queue.lock);
Target 0: (producer_consumer) stopped.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If we evaluate expression &lt;code class=&quot;highlighter-rouge&quot;&gt;*(long*)thread_return&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) e *(long*)thread_return
error: Couldn't apply expression side effects : Couldn't dematerialize a result variable: couldn't read its memory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Meaning that return variable in &lt;code class=&quot;highlighter-rouge&quot;&gt;customer_routine&lt;/code&gt; has some problem. If we look at source code, the return variable &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; is actually a local variable. We need to change it to heap space.&lt;/p&gt;

&lt;p&gt;(3) Segment Fault (2)
At this time, if you run the program, we will find some time the program runs correctly, but sometimes, it fall back to segment fault.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Process 80389 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
   70     /* Join threads, handle return values where appropriate */
   71
   72     result = pthread_join(producer_thread, NULL);
-&amp;gt; 73     if (0 != result) {
   74       fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result));
   75       pthread_exit(NULL);
   76     }
Target 0: (producer_consumer) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
(lldb) bt all
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
  thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100000c54 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:174
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #4
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100000c54 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:174
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;After joining &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt;, we investigate current stack state. It can be seen there are current three threads executing, and we can change to thread 3.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) thread select 3
* thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
libsystem_kernel.dylib`__psynch_mutexwait:
-&amp;gt;  0x7fff721faa46 &amp;lt;+10&amp;gt;: jae    0x7fff721faa50            ; &amp;lt;+20&amp;gt;
    0x7fff721faa48 &amp;lt;+12&amp;gt;: movq   %rax, %rdi
    0x7fff721faa4b &amp;lt;+15&amp;gt;: jmp    0x7fff721f1ae9            ; cerror_nocancel
    0x7fff721faa50 &amp;lt;+20&amp;gt;: retq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;These are assembly code, since our problem is linked to &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread.h&lt;/code&gt;, those program has been compiled. Here we need to jump to our code frame. 
Program will stop on this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) n
Process 90312 stopped
* thread #4, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000100000c21 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:170
   167        else
   168          queue_p-&amp;gt;front-&amp;gt;next-&amp;gt;prev = NULL;
   169
-&amp;gt; 170        queue_p-&amp;gt;front = queue_p-&amp;gt;front-&amp;gt;next;
   171        pthread_mutex_unlock(&amp;amp;queue_p-&amp;gt;lock);
   172
   173        /* Print the character, and increment the character count */
Target 0: (producer_consumer) stopped.
(lldb) e queue_p-&amp;gt;front
(queue_node_s *) $0 = 0x0000000100600020
(lldb) e queue_p-&amp;gt;front-&amp;gt;next
(queue_node_s *) $1 = 0x0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Apparently, some other thread steals &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_p-&amp;gt;front-&amp;gt;next&lt;/code&gt; away, we need to add another lock at the end of each loop. 
(4) Modify Global Variable
The third problem has nothing to do with &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;. When modifying global variable in a thread, we need use mutex to protect it, the change is made in &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt;.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="lldb" /><category term="Debug" /><summary type="html">How to debug a multi-thread program. This passage will discuss the usage of lldb for multi-threading program debug. You can find my code on my github code The code implements a simple producer-consumer pattern written in C, and use pthread to create new threads. Although you can compile it without any problem, there are four bugs in the code and our mission is to find them all using lldb. lldb For gdb users, some commands may different, but there is a command transformation table between gdb and lldb. Basic Commands # set breakpoint for xx function (lldb)breakpoint set -name xx # set breakpoint for method in class (lldb)breakpoint set -method xx # set breakpoint in file F line L (lldb)breakpoint set -file F -line L # set breakpoint in function address (lldb)breakpoint set -a funcaddr # list all breakpoints (lldb)breakpoint list # delete break point (lldb)breakpoint delete index ------------------------------ # run (lldb)r # next (lldb)n # step int (lldb)s # step out (lldb)f # continue (lldb)c ------------------------------ # watch some variable change when written (lldb)watchpoint set variable val ------------------------------ # variable in current frame (lldb)frame variable (lldb)fr v # print variable (lldb)p val ------------------------------ # find all frames (lldb)thread backtrace all (lldb)bt all # current frame (lldb)thread backtrace (lldb)bt # select frame X (lldb)frame select X # thread in current frame (lldb)thread list # select thread X (lldb)thread select X ---------------------------- # evaluate a expression E (lldb)expression E (lldb)e E # note expression can be used to dynamically change a value lldb share most commands with gdb. Note : Although watchpoint seems like a powerful tool, it's rather limited. On my MacBook Pro(x86_64), there are only 4 hardware watchpoint registers, each at most 8 bytes. So there can be only 48 byte range support. If you read the code, the most important structure is queue_t, since it includes one pthread_mutex_lock, which is 64 bytes, queue_t cannot fit in our watchlist registers. program (1) Failed to join producer thread: Invalid argument If we run the program without any modification, we will get this error. So why does this happen? Jumping into the code * thread #1, queue = 'com.apple.main-thread', stop reason = step over frame #0: 0x000000010000178e producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:72 69 /* Join threads, handle return values where appropriate */ 70 71 result = pthread_join(producer_thread, NULL); -&amp;gt; 72 if (0 != result) { 73 fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result)); 74 pthread_exit(NULL); 75 } Target 0: (producer_consumer) stopped. (lldb) p result (int) $3 = 3 Here we can see result=3, indicates we are trying to join a thread which doesn't exist. If we print g_num_prod, it returns 1, meaning that our producer_routine has not stopped (only producer_routine will change g_num_prod value). (lldb) bt all * thread #1, queue = 'com.apple.main-thread', stop reason = step over * frame #0: 0x000000010000177d producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:71 frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1 frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1 thread #2 frame #0: 0x00007fff721f1306 libsystem_kernel.dylib`swtch_pri + 10 frame #1: 0x00007fff723c322e libsystem_pthread.dylib`sched_yield + 11 frame #2: 0x0000000100001ae4 producer_consumer`producer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:133 frame #3: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #4: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #5: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13 thread #3 frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10 frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83 frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253 frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31 frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28 frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187 frame #6: 0x0000000100001c39 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:172 frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13 thread #4 frame #0: 0x00007fff721fb2ba libsystem_kernel.dylib`__write_nocancel + 10 frame #1: 0x00007fff7213c796 libsystem_c.dylib`_swrite + 87 frame #2: 0x00007fff721353bd libsystem_c.dylib`__sflush + 87 frame #3: 0x00007fff72137aa8 libsystem_c.dylib`__sfvwrite + 816 frame #4: 0x00007fff72141738 libsystem_c.dylib`__vfprintf + 16158 frame #5: 0x00007fff72166059 libsystem_c.dylib`__v2printf + 473 frame #6: 0x00007fff7213d742 libsystem_c.dylib`vfprintf_l + 54 frame #7: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187 frame #8: 0x0000000100001b4a producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:148 frame #9: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #10: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #11: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start We can see just before pthread_join there are still 4 frames. The reason here is the use of pthread_detach() will make a thread cannot join.</summary></entry><entry><title type="html">Dynamic Programming</title><link href="http://localhost:4000/blog/2018/06/02/dynamic_programming/" rel="alternate" type="text/html" title="Dynamic Programming" /><published>2018-06-02T00:00:00-07:00</published><updated>2018-06-02T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/06/02/dynamic_programming</id><content type="html" xml:base="http://localhost:4000/blog/2018/06/02/dynamic_programming/">&lt;h2 id=&quot;heading-dynamic-programming&quot;&gt;Dynamic Programming&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;空间优化&lt;/li&gt;
  &lt;li&gt;局部优化和全局最优实现时间优化&lt;/li&gt;
  &lt;li&gt;记忆化搜索&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动态规划的4要点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态
a) 最优解/Max/Min
b) Yes/No
c) Count(*)&lt;/li&gt;
  &lt;li&gt;方程(状态之间的联系)&lt;/li&gt;
  &lt;li&gt;初始化&lt;/li&gt;
  &lt;li&gt;答案&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态规划的空间规划
House Robber
&lt;a href=&quot;https://www.lintcode.com/problem/house-robber/description&quot;&gt;website&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;状态&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt; 表示前i个房子中，偷到的最大价值&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i] = max(f[i-1], f[i-2]+A[i])&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[0] = A[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f[1] = max(A[0],A[1])&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[n-1]&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一维优化特点&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;是由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i-1]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i-2]&lt;/code&gt;决定，这样可以转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i%2]&lt;/code&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-1)%2]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-2)%2]&lt;/code&gt;决定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态state
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;表示前i个方子中，&lt;strong&gt;偷了第i个房子的&lt;/strong&gt;，偷到的最大价值&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i] = max(f[i-2], f[i-3]) + A[i]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[0] = A[0]; f[1] = A[1]; f[2] = A[0] + A[2];&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;max{f[i]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i%3]&lt;/code&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-2)%3]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-3)%3]&lt;/code&gt;决定&lt;/p&gt;

&lt;p&gt;Maximal Square
&lt;a href=&quot;https://www.lintcode.com/problem/maximal-square/description&quot;&gt;website&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j]&lt;/code&gt; 表示以&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;为正方形右下角可以扩展的最大边长&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if matrix[i][j] == 1
  f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1;
if matrix[i][j] == 0
  f[i][j] = 0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f[i][0] = matrix[i][0]
f[0][j] = matrix[0][j]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;max{f[i][j]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[2][n]&lt;/code&gt;的矩阵即可&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if matrix[i][j] == 1
	f[i%2][j] = min(f[(i-1)%2][j], f[i%2][j-1], f[(i-1)%2][j-1]) + 1;
if matrix[i][j] = 0
	f[i%2][j] = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;局部最优和全局最优&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;maximum subarray 
&lt;a href=&quot;https://www.lintcode.com/problem/maximum-subarray/description&quot;&gt;website&lt;/a&gt;
use presum array&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (j = 0-&amp;gt;n)
	for (i = 0-&amp;gt;j)
		presum[j+1] - presum[i](add dummy 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;local[i]&lt;/code&gt;表示包括第i个元素能够找到的最大值(一定要取第i个元素能够取得的最大值)
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[i]&lt;/code&gt;表示全局前i个元素中能够找到的最大值&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;local[i] = Max(nums[i], local[i-1]+nums[i]);&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[i] = Max(local[i], global[i-1]);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;loacl[0] = global[0] = nums[0]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[n-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;maximum product subarray
&lt;a href=&quot;https://www.lintcode.com/problem/maximum-product-subarray/description&quot;&gt;website&lt;/a&gt;
use preproduct array
最初加一个1&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (j = 0-&amp;gt;n)
	for (i = 0-&amp;gt;j)
		preproduct[j+1] / preproduct[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;need to record max, min&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;min[i]&lt;/code&gt; 表示前i个数包括第i个数找到的最小乘积
&lt;code class=&quot;highlighter-rouge&quot;&gt;max[i]&lt;/code&gt;表示前i个数包括第i个数找到的最大乘积&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;min[i] = Min(nums[i], Min(min[i-1] * nums[i], max[i-1] * nums[i]));
max[i] = Max(nums[i], Max(max[i-1] * nums[i], min[i-1] * nums[i]));
global[i] = Max(global[i-1], max[i]);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;min[0] = max[0] = nums[0];&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;gloabl[n-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Best time to buy and sell stocks IV 
&lt;a href=&quot;https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iv/description&quot;&gt;website&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j]&lt;/code&gt;表示前i天进行j次交易能够获得的最大收益&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j] = max{f[x][j-1] + profit(x+1, i)} {x=0-&amp;gt;i-1}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][0] = 0, f[0][i] = -INT_MAX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[n-1][k]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A second method:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;mustSell[i][j]&lt;/code&gt;表示前i天，最多进行j次交易，前i天必须sell的最大获益
&lt;code class=&quot;highlighter-rouge&quot;&gt;globalbest[i][j]&lt;/code&gt;表示前i天，最多进行j次交易，第i天可以不sell的最大获益&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gain = prices[i] - prices[i-1]
mustsell[i][j] = Max(globalbest[i-1][j-1] + gain, mustsell[i-1][j]+gain)
globalbest[i][j] = Max(globalbest[i-1][j], mustsell[i][j])
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mustsell[0][i] = globalbest[0][j] = 0;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;答案
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;globalbest[n-1][k]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;记忆化搜索&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;longest increasing continuous&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Algorithm" /><summary type="html">Dynamic Programming 空间优化 局部优化和全局最优实现时间优化 记忆化搜索</summary></entry><entry><title type="html">LLVM Intro</title><link href="http://localhost:4000/blog/2018/05/31/llvm/" rel="alternate" type="text/html" title="LLVM Intro" /><published>2018-05-31T00:00:00-07:00</published><updated>2018-05-31T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/31/llvm</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/31/llvm/">&lt;p&gt;I've been reading LLVM material for a whole day. It's a really exicting work by Chris Lattner(He build the project during his graduate study, how amazing!)&lt;/p&gt;
&lt;h3 id=&quot;heading-1-intro&quot;&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;LLVM is a &lt;strong&gt;compiler&lt;/strong&gt;. Different from other compilers, LLVM can achieve cross-platform compilation. LLVM has intermediate representation(IR) which is a great innovation and make the project independent from platform. Since it has backend to translate IR to target machine without human interference. This &lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/llvm.html&quot;&gt;page&lt;/a&gt; provides an introductory material for LLVM users. 
&lt;img src=&quot;/assets/images/compiler_arch.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In compiler classes, we know compiler can be divided into front end and back end. The front end for compiler is &lt;strong&gt;Clang&lt;/strong&gt;, and back-end is simply LLVM it self which helps to translate IR into different assembly languages on various machine. Here our focus is on &lt;strong&gt;pass&lt;/strong&gt;. Passes translate IR to IR and help to optimize code generation. 
These intermediate representtaion is more &lt;strong&gt;regular&lt;/strong&gt; structurally. It's easier for us to analyze these assembly language compared to x86.&lt;/p&gt;

&lt;p&gt;To install LLVM, simply follow these 12 steps:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. svn co https://user@llvm.org/svn/llvm-project/llvm/tags/RELEASE_500/final llvm
2. cd llvm/tools
3. svn co http://llvm.org/svn/llvm-project/cfe/tags/RELEASE_500/final clang
4. cd clang/tools # (To be clear, you are now in llvm/tools/clang/tools)
5. svn co http://llvm.org/svn/llvm-project/clang-tools-extra/tags/RELEASE_500/final extra
6. cd ../../../../llvm/projects # (To be clear, you are now in llvm/projects)
7. svn co http://llvm.org/svn/llvm-project/compiler-rt/tags/RELEASE_500/final compiler-rt
8. cd ../../.. (You are now in your desktop directory)
9. mkdir build (if you have not already done so)
10. cd build (You are now in your build directory)
11. cmake -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; -DLLVM_TARGET_ARCH=X86
-DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLVM_BUILD_EXAMPLES=1
-DCLANG_BUILD_EXAMPLES=1 -G &quot;Unix Makefiles&quot; ../source/llvm/
12. 'make -j 8' (from within the build directory to start the process)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The material is copied from a &lt;a href=&quot;https://www.youtube.com/watch?v=VKIv_Bkp4pk&quot;&gt;talk&lt;/a&gt; given by Mike Shah.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-try-function-pass&quot;&gt;2. Try Function Pass&lt;/h3&gt;
&lt;p&gt;I simply follow the steps descirbed by &lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/llvm.html&quot;&gt;page&lt;/a&gt;. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git clone https://github.com/sampsyo/llvm-pass-skeleton.git&lt;/code&gt;
and&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd llvm-pass-skeleton
$ mkdir build
$ cd build
$ cmake ..  # Generate the Makefile.
$ make  # Actually build the pass.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so test.cpp&lt;/code&gt;
This code cannot work on my machine. And I add one flag:
&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -lstdc++ test.cpp&lt;/code&gt;
It works!&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;Module&lt;/strong&gt; represents a source file (roughly) or a translation unit (pedantically). Everything else is contained in a Module.&lt;/p&gt;

&lt;p&gt;Most notably, Modules house &lt;strong&gt;Functions&lt;/strong&gt;, which are exactly what they sound like: named chunks of executable code. (In C++, both functions and methods correspond to LLVM Functions.)&lt;/p&gt;

&lt;p&gt;Aside from declaring its name and arguments, a Function is mainly a container of &lt;strong&gt;BasicBlocks&lt;/strong&gt;. The basic block is a familiar concept from compilers, but for our purposes, it’s just a contiguous chunk of instructions.&lt;/p&gt;

&lt;p&gt;An &lt;strong&gt;Instruction&lt;/strong&gt;, in turn, is a single code operation. The level of abstraction is roughly the same as in RISC-like machine code: an instruction might be an integer addition, a floating-point divide, or a store to memory, for example.
&lt;strong&gt;Module, Functions, Block and Instruction&lt;/strong&gt; are C++ classes inherit from a base class &lt;strong&gt;Value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If you want to see LLVM IR, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;clang -emit -llvm -S -o -test.c&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;namespace {
	struct SkeletonPass : public FunctionPass {
		static char ID;
		SkeletonPass() : FunctionPass(ID) {}

		virtual bool runOnFunction(Functon &amp;amp;F) {
			errs() &amp;lt;&amp;lt; &quot;In a function called &quot; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &quot;!\n&quot;;
			errs() &amp;lt;&amp;lt; &quot;Function body:\n&quot;;
			F.print(llvmLerrs());
			for (auto &amp;amp;B : F) {
				errs() &amp;lt;&amp;lt; &quot;Basic block:\n&quot;;
				B.print(llvm::errs(), true);

				for (auto &amp;amp;I : B) {
					errs() &amp;lt;&amp;lt; &quot;Instruction: &quot;;
					I.print(llvm::errs(), true);
				}
			}
			return false;
		}
	};
}
char SkeletonPass::ID = 0;
static void registerSkeletonPass(const PassManagerBuilder&amp;amp;, legacy::PassManagerBase &amp;amp;PM) {
	PM.add(new SkeletonPass());
}
static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;heading-3-link-with-a-run-time-library&quot;&gt;3. Link with a Run-time library&lt;/h3&gt;
&lt;p&gt;You can write your run-time behavior in C and link it with the program you've compiled. And LLVM can help you link them together.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Get the function to call from our runtime library.
LLVMContext&amp;amp; Ctx = F.getContext();
Constant* logFunc = F.getParent()-&amp;gt;getOrInsertFunction(
  &quot;logop&quot;, Type::getVoidTy(Ctx), Type::getInt32Ty(Ctx), NULL
);

for (auto&amp;amp; B : F) {
  for (auto&amp;amp; I : B) {
    if (auto* op = dyn_cast&amp;lt;BinaryOperator&amp;gt;(&amp;amp;I)) {
      // Insert *after* `op`.
      IRBuilder&amp;lt;&amp;gt; builder(op);
      builder.SetInsertPoint(&amp;amp;B, ++builder.GetInsertPoint());

      // Insert a call to our function.
      Value* args[] = {op};
      builder.CreateCall(logFunc, args);

      return true;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The tool you need are &lt;code class=&quot;highlighter-rouge&quot;&gt;Module::getOrInsertFunction&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;IRBuilder::CreateCall&lt;/code&gt;. The former adds a declaration for your runtime function &lt;code class=&quot;highlighter-rouge&quot;&gt;logop&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void logop(int i) {
  printf(&quot;computed: %i\n&quot;, i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cc -c rtlib.c
$ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c example.c
$ cc example.o rtlib.o
$ ./a.out
12
computed: 14
14
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">I've been reading LLVM material for a whole day. It's a really exicting work by Chris Lattner(He build the project during his graduate study, how amazing!) 1. Intro LLVM is a compiler. Different from other compilers, LLVM can achieve cross-platform compilation. LLVM has intermediate representation(IR) which is a great innovation and make the project independent from platform. Since it has backend to translate IR to target machine without human interference. This page provides an introductory material for LLVM users.</summary></entry><entry><title type="html">Vim Script</title><link href="http://localhost:4000/blog/2018/05/26/Vim_script/" rel="alternate" type="text/html" title="Vim Script" /><published>2018-05-26T00:00:00-07:00</published><updated>2018-05-26T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/26/Vim_script</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/26/Vim_script/">&lt;p&gt;Vim has its own scripting language, most standard dynamic-language features&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:vmap &amp;lt;expr&amp;gt; aa Select_Entire_File()
:nmap x :call Comment_To_EOF()
:imap &amp;lt;expr&amp;gt; \p Insert_Balanced_Tags('&amp;lt;p&amp;gt;')
:nmap	;y :call Taggle_Syntax()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Variables, expression, control structures, build-in functions … 
For full details:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:help vim-scrpt-intro
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For endless examples:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://vim.sourceforge.net/scripts/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For detailed work examples:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.ibm.com/developerworks/library/l-vim-script-1/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Five ways to execute vim scripts
(1) simplest: put them in &lt;code class=&quot;highlighter-rouge&quot;&gt;.vim&lt;/code&gt; file
and then execute it with &lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source ./scriptfile.vim&lt;/code&gt;
(2) &lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt; the file you are editing
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source %&lt;/code&gt;
(3) If file somewhere in &lt;code class=&quot;highlighter-rouge&quot;&gt;$VIMRUNTIME&lt;/code&gt; path
&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime scriptfile.vim&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;:runtime&lt;/code&gt; are handy ways of factoring out parts of your &lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;
More useful in a live session:
Can type commands directly on command-line:
&lt;code class=&quot;highlighter-rouge&quot;&gt;:call MyBackupFunc(expand('%'), {'all':1, 'save':'recent'})&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:command SF source scriptfile.vim
:command -nargs=1 MBF call MyBackupFunc(expand(&amp;lt;q-args&amp;gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Even more useful is triggering a command from Normal mode…
Create &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; to type it for you:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap ;s :source scriptfile.vim&amp;lt;CR&amp;gt;
:nmap \b :call MyBackupFunc(expand('%'), {'all' : 1})&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For the very least effort&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:autocmd BufReadPost *.txt source scriptfile.vim
:autocmd WinLeave * call MyBackupFunc(expand('%'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;heading-statement&quot;&gt;Statement&lt;/h3&gt;
&lt;p&gt;all statements terminated by newline:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &quot;Starting&quot;
call Phase(1)
echo &quot;Done&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To continue across multiple lines, start next line with backslash:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let full_name = 
\ first_name . ' ' . middle_initial . ' ' . family_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To put two statements on one line, separate with vertical bar:
&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;Starting&quot; | call Phase(1) | call Phase(2) | echo &quot;Done&quot;&lt;/code&gt;
 Leading colon is also allowed in a Vim script, but not required:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function! Tidy_and_save()
	set expandtabs
	%retab!
	write
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-values&quot;&gt;Values&lt;/h3&gt;
&lt;p&gt;Four build-in types: &lt;code class=&quot;highlighter-rouge&quot;&gt;String, Number, List, and Dictionary&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1527350515440.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-commands&quot;&gt;commands&lt;/h3&gt;
&lt;p&gt;Start with double quote&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;
It run to end-of-line:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; This is a comment
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;So maybe add a more familiar marker&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call Setup(0) &quot; // comment
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-variables&quot;&gt;Variables&lt;/h3&gt;
&lt;p&gt;All assignments require &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; keyword
Vars can store numbers, strings, lists, dictionaries, or just function refs:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = &quot;Damian&quot;
let height = 170
let haha = {&quot;Vim&quot;, &quot;asdjl&quot;, &quot;key&quot;}
let duration = {&quot;vim&quot;:32, &quot;pasd&quot;:32}
let task = function('teach')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The variable type initialized with determinte the type of variable for the remaining time. 
if you &lt;code class=&quot;highlighter-rouge&quot;&gt;let duration = 90&lt;/code&gt; will cause a type error. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;unlet duration&lt;/code&gt;
&lt;img src=&quot;/assets/images/1527353138645.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;each scope name also a symbol table&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g:varname
g:['varname']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for varname in keys(b:)
	unlet b:[varname]
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1527353463462.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Give direct access to vim environment&lt;/p&gt;

&lt;h3 id=&quot;heading-expressions&quot;&gt;Expressions&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1527353726859.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; is string concatenation
All comparators do both string and numeric comparison
string comparisons honour &lt;code class=&quot;highlighter-rouge&quot;&gt;ignorecase&lt;/code&gt;
but can be explicitly marked case-sensitive(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)
case-insensitive(&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if name ==? 'Batman'
	echo &quot;I'm a Batman&quot;
else if name ==# 'ee cummings'
	echo &quot;asjdlj&quot;
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Most important limitation is on arithmetic
Numeric expressions are &lt;strong&gt;integer only&lt;/strong&gt;
Some floating point support in Vim 7.2
Common mistake:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for filenum in range(filecount)
	&quot;Show progress...
	echo(file / filecount * 100).'% done'
	&quot;Make progress...
	call progress_file(filenum)
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This will always echo &lt;code class=&quot;highlighter-rouge&quot;&gt;Now 0% done&lt;/code&gt;
have to use &lt;code class=&quot;highlighter-rouge&quot;&gt;filenum * 100 / filecount&lt;/code&gt;
Another notice point:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for result in result_list
	let sum += result
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-controlflow&quot;&gt;ControlFlow&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if condition
	statements()
elseif other_condition
	other_statements
else
	still()
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while condition
	statements()
endwhile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for varname in list
	statements()
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Parallel iteration&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for [var1, var2, etc] in listoflists
	statements()
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let g:words = {1:&quot;one&quot;, 2:&quot;two&quot;, 3:&quot;many&quot;, 4:&quot;lots&quot;}
for [key, val] in items(g:words)
	echo key. &quot;: &quot;.val
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for number in list_of_numbers
	if number &amp;lt; 0
		continue &quot;go to next loop
	elseif number &amp;gt; 9
		break &quot;Exit loop completely
	endif 
	echo number
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Vim" /><summary type="html">Vim has its own scripting language, most standard dynamic-language features :vmap &amp;lt;expr&amp;gt; aa Select_Entire_File() :nmap x :call Comment_To_EOF() :imap &amp;lt;expr&amp;gt; \p Insert_Balanced_Tags('&amp;lt;p&amp;gt;') :nmap ;y :call Taggle_Syntax()</summary></entry><entry><title type="html">Vim abbreviation and map</title><link href="http://localhost:4000/blog/2018/05/25/Vim-abbreviation-and-map/" rel="alternate" type="text/html" title="Vim abbreviation and map" /><published>2018-05-25T00:00:00-07:00</published><updated>2018-05-25T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/25/Vim%20abbreviation%20and%20map</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/25/Vim-abbreviation-and-map/">&lt;h2 id=&quot;heading-vim-abbreviation-and-map&quot;&gt;Vim abbreviation and map&lt;/h2&gt;
&lt;p&gt;abbreviation&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:abbreviate hdco aperjump.com
:abbreviate ww wei@aperjump.me
:ab ww wei@aperjump.me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;There are strict limitations on what you can use a an abbreviation&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;must be an identifier consisting entirely of keyword characters:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab url http://www.baidu.com
ab krd Kind regards, &amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;Damian Conway
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;must consist entirely of non-keyword characters, except for the last one
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab #1 I'll make that my number one priority
ab --c &amp;lt;CR&amp;gt;----cut------cut-----cut-&amp;lt;C-O&amp;gt;:center&amp;lt;CR&amp;gt;&amp;lt;DOWN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;must end in a &lt;strong&gt;non-keyword&lt;/strong&gt; character
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab ph# +1-802-555-1122
ab ??? //
ab orz! I'm not worthy
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;expand abbreviation
Abbreviations also require some trailing context to know they've been entered
–&amp;gt; you need to type a non-keyword character after the abbreviation before it will be expanded
You can expand an abbreviation without trailing context by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL-]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;How to review abbreviation
If you type&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:abbreviate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;without an argumant, you can get a list of the active abbreviations
To remove abs, just type &lt;code class=&quot;highlighter-rouge&quot;&gt;:unabbreviate bqc&lt;/code&gt; or clear all &lt;code class=&quot;highlighter-rouge&quot;&gt;:abclear&lt;/code&gt;
To deactivate them type a literal &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;CRTL-V&amp;gt;&lt;/code&gt; before the abbreviation
For example, if you frequently need to save to a particular file:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:ab bak /usr/local/tmp/backup/damian/checkpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;A better option is &lt;code class=&quot;highlighter-rouge&quot;&gt;iabbrev&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cabbrev&lt;/code&gt; versions
With these you can tell Vim exactly where to expand the abbreviation:
Only in insertions:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:iabbrev bqc &amp;lt;blockquote&amp;gt;&amp;lt;cite&amp;gt;&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&amp;lt;/cite&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;UP&amp;gt;&amp;lt;TAB&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;only in command line:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:cabbrev bak /usr/local/tmp/backup/damian/checkpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;You can specify an abbreviation should expand to the result of some expression in the vimmish command language&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:iabbr &amp;lt;expr&amp;gt; TS strftime(&quot;%c&quot;)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:iabbr &amp;lt;expr&amp;gt; PPP getreg('')&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-1-maps&quot;&gt;1. Maps&lt;/h3&gt;
&lt;p&gt;Abbreviations are grreat, but suffer from two major constraints
They're only available in Insert mode and on the command line
They require an extra character typed after them&lt;/p&gt;

&lt;p&gt;Mays remedy both those problems
A map creates a sequence that is expanded as soon as typed
A &lt;strong&gt;macro&lt;/strong&gt;
We can specify maps for specific modes&lt;/p&gt;

&lt;h4 id=&quot;heading-11-insert-map&quot;&gt;1.1 Insert map&lt;/h4&gt;
&lt;p&gt;They can be used to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;iabbr&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:imap ww http://www.google.com
:imap ee wei@aperjump.me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;advantage: don't require additional character to be typed&lt;/p&gt;

&lt;h4 id=&quot;heading-12-normal-map&quot;&gt;1.2 Normal map&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap X dip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;dip: delete the interior of paragraph
Likewise, if visual block mode more useful than visual line mode.
We can use this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap v &amp;lt;C-V&amp;gt;
:nmap &amp;lt;Space&amp;gt; &amp;lt;PageDown&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Or we can streamline file navigation:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap &amp;lt;DOWN&amp;gt; :next&amp;lt;CR&amp;gt;
:nmap &amp;lt;UP&amp;gt; prev&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;heading-13-command-line-maps&quot;&gt;1.3 Command line maps&lt;/h4&gt;
&lt;p&gt;If you frequently write to a backup file:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:w ~/backup/latest&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can add this to &lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmap wb w ~/backup/latest&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;or we can simplify subdirectory tours:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:cmap *** **/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;which then allows:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:next examples/***.c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Vim" /><summary type="html">Vim abbreviation and map abbreviation :abbreviate hdco aperjump.com :abbreviate ww wei@aperjump.me :ab ww wei@aperjump.me There are strict limitations on what you can use a an abbreviation must be an identifier consisting entirely of keyword characters: ab url http://www.baidu.com ab krd Kind regards, &amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;Damian Conway must consist entirely of non-keyword characters, except for the last one ab #1 I'll make that my number one priority ab --c &amp;lt;CR&amp;gt;----cut------cut-----cut-&amp;lt;C-O&amp;gt;:center&amp;lt;CR&amp;gt;&amp;lt;DOWN&amp;gt; must end in a non-keyword character ab ph# +1-802-555-1122 ab ??? // ab orz! I'm not worthy</summary></entry><entry><title type="html">Syntax Analysis</title><link href="http://localhost:4000/blog/2018/05/19/syntax_analysis/" rel="alternate" type="text/html" title="Syntax Analysis" /><published>2018-05-19T00:00:00-07:00</published><updated>2018-05-19T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/19/syntax_analysis</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/19/syntax_analysis/">&lt;h3 id=&quot;heading-1-intro&quot;&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;main topic: parsing methods
&lt;img src=&quot;/assets/images/1526745213800.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The parser constructs a parse tree and passes it to the rest of the compiler for further processing.&lt;/p&gt;

&lt;p&gt;Two parser methods: &lt;strong&gt;top-down&lt;/strong&gt;(from root to leaves) and &lt;strong&gt;bottom-up&lt;/strong&gt;(from leaves to root). The input for parser is scanned from left to right, one symbol at a time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LL&lt;/strong&gt; and &lt;strong&gt;LR&lt;/strong&gt; are expressive tools to describe most of the syntactic constructs in modern programming language. Parser implemented by hand often use &lt;strong&gt;LL&lt;/strong&gt; grammars. Parser for larger class of &lt;strong&gt;LR&lt;/strong&gt; grammars are usually constructed using automated tools.&lt;/p&gt;

&lt;p&gt;In practice, there are a number of tasks that might be conducted during parsing, such as collecting information about various tokens into the symbol table, performing type checking and other kind of semantic analysis and generating intermediate code.&lt;/p&gt;

&lt;h4 id=&quot;heading-11-representative-grammars&quot;&gt;1.1 Representative Grammars&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1526745812598.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This expression belongs to the class of &lt;strong&gt;LR&lt;/strong&gt; grammars that are suitable for &lt;strong&gt;bottom-up&lt;/strong&gt; parsing. This grammar can be adapted to handle additional operators and additional levels of precedence. However, it cannot be used for &lt;strong&gt;top-down&lt;/strong&gt; parsing because it is left-recursive.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;left-recursive —&amp;gt; bottom up
non-left-recursive —&amp;gt; top down&lt;/p&gt;
  &lt;h4 id=&quot;heading-12-error-handling&quot;&gt;1.2 Error handling&lt;/h4&gt;
  &lt;p&gt;Two strategies: &lt;strong&gt;panic mode&lt;/strong&gt; and &lt;strong&gt;phrase-level recovery&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(1) panic mode&lt;/p&gt;

&lt;p&gt;On discovering an error, the parser discards input symbols one at a time until one of a designed set of &lt;strong&gt;synchronizing token&lt;/strong&gt; is found. The synchronizing tokens are usually delimiters, such as semicolon or &lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(2) phrase level recovery&lt;/p&gt;

&lt;p&gt;On discovering an error, a parser may perform local correction on the remaining input; that is, it may replace a prefix of the remaining input by some string that allows the parser to continue.&lt;/p&gt;

&lt;p&gt;A typical local correction is to replace a comma by a semicolon, delete an extraneous semicolon, or insert a missing semicolon.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-context-free-grammar&quot;&gt;2. Context-free Grammar&lt;/h3&gt;

&lt;p&gt;definition: A context-free grammar consists of terminals, nonterminals, a start symbol, and productions.&lt;/p&gt;

&lt;p&gt;(1) terminals are the basic symbols from which strings are formed. &lt;strong&gt;We assume terminals are the first components of the tokens output by the lexical analyzer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;(2) nonterminals are syntactic variables that denote sets of strings. The sets of strings denoted by nonterminals help define the language generated by the grammar. Nonterminals impose a hierarchical structure on the language that is key to syntax analysis and translation.&lt;/p&gt;

&lt;p&gt;(3) start symbol is the set of strings it denotes is the language generated by the grammar.&lt;/p&gt;

&lt;p&gt;(4) production specify the manner in which terminals and nonterminals can be combined to form strings.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stmt -&amp;gt; if (expr) stmt else stmt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If $\S \xrightarrow{*} \alpha$, where $S$ is the start symbol of a grammar $G$, we say that $\alpha$ is the &lt;strong&gt;sentential form&lt;/strong&gt; of $G$. A sentential form may contain both terminals and nontermnials or even empty string. A &lt;strong&gt;sentence&lt;/strong&gt; of $G$ is a sentential form with no nonterminals. The language generated by a grammar is its set of sentences.&lt;/p&gt;

&lt;p&gt;Thus a string of terminals $\omega$ is in $L(G)$, the language generated by $G$. iff $\omega$ is a sentence of $G$, or $S \xrightarrow{*} \omega$. A language that can be generated by a grammar is said to be &lt;strong&gt;context-free&lt;/strong&gt; grammar.&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;leftmost&lt;/strong&gt; derivations, the leftmost nonterminal in each sentential is always chosen. 
$\alpha \xrightarrow{lm} \beta$&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;rightmost&lt;/strong&gt; derivations, the rightmost nonterminal is always chosen. 
$\alpha \xrightarrow{rm} \beta$&lt;/p&gt;
&lt;h4 id=&quot;heading-21-parse-tree&quot;&gt;2.1 Parse Tree&lt;/h4&gt;
&lt;p&gt;A parse tree is a graphical representation of a derivation that filters out the order in which productions are applied to replace nonterminals. 
&lt;img src=&quot;/assets/images/1526748378855.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The leaves of a parse tree are labeled by nonterminals or terminals and read from left to right constitute a sentential form, called the &lt;strong&gt;yield&lt;/strong&gt; or &lt;strong&gt;frontier&lt;/strong&gt; of the tree.&lt;/p&gt;

&lt;p&gt;A parse tree ignores variations in the order in which symbols in sentential forms are replaced, there is a many-to-one relationship between derivations and parse tree. **we shall frequently parse by producing a leftmost or a rightmost derivation, since there is a one-to-one relationship between parse trees and either leftmost or rightmost derivations.&lt;/p&gt;

&lt;h4 id=&quot;heading-22-context-free-grammar-and-regular-expression&quot;&gt;2.2 context-free grammar and regular expression&lt;/h4&gt;

&lt;p&gt;every constructs that can be described by a regular expression can be described  by a grammar, but not vice-versa. Every regular expression is a context-free grammar, but not vice-versa.&lt;/p&gt;

&lt;h3 id=&quot;heading-3-writing-a-grammar&quot;&gt;3. Writing a Grammar&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1526750747974.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if E1 then if E2 then S1 else S2&lt;/code&gt;  has two parse trees. 
&lt;img src=&quot;/assets/images/1526750795078.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How to rewrite the grammar?&lt;/p&gt;

&lt;p&gt;idea: the statement between &lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; must be matched. 
&lt;img src=&quot;/assets/images/1526762609720.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;heading-31-eliminate-left-recursion&quot;&gt;3.1 eliminate left recursion&lt;/h4&gt;
&lt;p&gt;A grammar is &lt;strong&gt;left recursive&lt;/strong&gt; if it has a nonterminal $A$ such that there is a derivation $A \xrightarrow{+} A\alpha$. Here is one rule $A \xrightarrow{}A\alpha | \beta$ can be replaced by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \beta A' \\
	 A' \rightarrow \alpha A' | \epsilon&lt;/script&gt;

&lt;p&gt;Here we can change the rule in first section to this one (using the rule above)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id&lt;/script&gt;

&lt;p&gt;One general rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow A\alpha_1 | A\alpha_2 | ...|A\alpha_m | \beta_1 | \beta_2 | ... | \beta_m&lt;/script&gt;

&lt;p&gt;can be replaced by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \beta_1A' | \beta_2A' | ... | \beta_n A' \\
	 A' \rightarrow \alpha_1A' | \alpha_2A' | ... | \alpha_m A' | \epsilon&lt;/script&gt;

&lt;h4 id=&quot;heading-32-left-factoring&quot;&gt;3.2 Left Factoring&lt;/h4&gt;
&lt;p&gt;Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive, top-down, parsing. When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen that we can make the right choice.&lt;/p&gt;

&lt;p&gt;For example: original rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \alpha \beta_1 | \alpha\beta_2&lt;/script&gt;

&lt;p&gt;can be left factor into&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \alpha A' \\
	 A \rightarrow \beta_1 | \beta_2&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526764155565.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-4-top-down-parsing&quot;&gt;4. Top-down parsing&lt;/h3&gt;
&lt;p&gt;Top-down parsing can be viewed as finding a &lt;strong&gt;leftmost&lt;/strong&gt; derivation for an input string.&lt;/p&gt;

&lt;p&gt;main problem is find production for nonterminal A.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;recursive descent parsing&lt;/strong&gt;(requre backtracking).&lt;/p&gt;

&lt;p&gt;predictive parsing is a special case of recursive parsing, where no backtracing is required. Predictive parsing choose the correct A-production by looking ahead at the input a fixed number of symbols.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526764567285.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The class of grammars for which we can construct predictive parsers looking k symbols ahead in the input is called &lt;strong&gt;LL(k)&lt;/strong&gt; class.&lt;/p&gt;
&lt;h4 id=&quot;heading-41-recursive-descent-parsing&quot;&gt;4.1 Recursive-Descent Parsing&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void A() {
	Choose an A-production, A -&amp;gt; X1X2...Xk;
	for (i = 1 to k) {
		if (Xi is a nonterminal)
			call procedure Xi();
		else if (Xi equals the current input symbol a)
			advance the input to the next symbol;
		else
			catch error
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To allow backtracking, the code needs to be modified. First, we cannot choose a unique A-production in line (1), so we must try several productions. The failure in last &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; should return back to the first choice procedure. Only if there is no more A-production to try, there is a true error.&lt;/p&gt;

&lt;h4 id=&quot;heading-42-first-and-follow&quot;&gt;4.2 FIRST and FOLLOW&lt;/h4&gt;
&lt;p&gt;$FIRST$ and $FOLLOW$ allow us to choose which production to apply, based on the next input symbol.&lt;/p&gt;

&lt;p&gt;Consider non-terminal A, production $A\rightarrow\alpha$, and we have input symbol $t$&lt;/p&gt;

&lt;p&gt;$T[A,t] = \alpha$ in two cases($T$ is transition table):&lt;/p&gt;

&lt;p&gt;(1) if $\alpha \xrightarrow{*} t\beta$&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$\alpha$ can derive a $t$ in the first position&lt;/li&gt;
  &lt;li&gt;we say that $t\in FIRST(\alpha)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) if $A\rightarrow\alpha$ and $\alpha \xrightarrow{&lt;em&gt;} \epsilon$ and $S \xrightarrow{&lt;/em&gt;}\beta At\delta$&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;useful if stack has $A$, input is $t$, and $A$ cannot derive $t$&lt;/li&gt;
  &lt;li&gt;In this case only option is to get rid of $A$ by deriving $\epsilon$&lt;/li&gt;
  &lt;li&gt;we say that $t\in FOLLOW(A)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$FIRST(\alpha)$, where $\alpha$ is any string of grammar symbols, to be the set of terminals that begin strings derived from $\alpha$. For example $A\xrightarrow{&lt;em&gt;}c\gamma$, so $c$ is in $FIRST(A)$. $FIRST(X)={t|X \xrightarrow{&lt;/em&gt;}t\alpha} \cup {\epsilon | X \xrightarrow{*} \epsilon}$
Algo:&lt;/p&gt;

&lt;p&gt;(1) if $FIRST(t) = {t}$(t is terminal)&lt;/p&gt;

&lt;p&gt;(2) $\epsilon \in FIRST(X)$ if $X\rightarrow\epsilon$ or if $X\rightarrow A_1…A_n$ and $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$&lt;/p&gt;

&lt;p&gt;(3) $FIRST(\alpha) \subseteq FIRST(X)$ if $X\rightarrow A_1…A_n\alpha$ and  $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$&lt;/p&gt;

&lt;p&gt;$FOLLOW(A)$ for nonterminal $A$ is the set of terminals $a$ that can appear immediately to the right of $A$ in some &lt;strong&gt;sentential form&lt;/strong&gt;; that is, the set of terminals $a$ such that there exists a derivation of the form 
$S\xrightarrow{&lt;em&gt;}\alpha A\alpha\beta$
In addition, if $A$ can be the rightmost symbol in some sentential form, then $$$ is in $FOLLOW(A)$; $$$ reprents &quot;endmark&quot;. $FOLLOW(X) = {t|S\xrightarrow{&lt;/em&gt;} \beta Xt\delta}$&lt;/p&gt;

&lt;p&gt;Intuition:&lt;/p&gt;

&lt;p&gt;If $X\rightarrow AB$ then $FIRST(B) \subseteq FOLLOW(A)$ and $FOLLOW(X) \subseteq FOLLOW(B)$&lt;/p&gt;

&lt;p&gt;If $B\xrightarrow{*}\epsilon$ then $FOLLOW(X) \subseteq FOLLOW(A)$
If $S$ is the start symbol then $$ \in FOLLOW(S)$&lt;/p&gt;

&lt;p&gt;Algo:&lt;/p&gt;

&lt;p&gt;(1) $$\in FOLLOW(S)$&lt;/p&gt;

&lt;p&gt;(2) $FIRST(\beta) - {\epsilon} \subseteq FOLLOW(X)$ for each production $A \rightarrow \alpha X\beta$($FOLLOW$ sets are just terminals, no empty set)&lt;/p&gt;

&lt;p&gt;(3) $FOLLOW(A) \subseteq FOLLOW(X)$ for each production  $A \rightarrow \alpha X\beta$ where $\epsilon \in FIRST(\beta)$&lt;/p&gt;

&lt;h4 id=&quot;heading-43-ll1&quot;&gt;4.3 LL(1)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;no left-recursive or ambiguous grammar in LL(1)&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A grammar $G$ is LL(1) iff whenever $A\rightarrow\alpha&lt;/td&gt;
      &lt;td&gt;\beta$ are two distinct productions of $G$.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526769704732.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our goal here is to construct a parsing table $T$ for context-free grammar $G$&lt;/p&gt;

&lt;p&gt;For each production $A\rightarrow \alpha$ in $G$ do:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For each terminal $t \in FIRST(\alpha)$ do 
      $T[A,t] = \alpha$&lt;/li&gt;
  &lt;li&gt;If $\epsilon \in FIRST(\alpha)$ for each $t \in FOLLOW(A)$ do
      $T[A,t] = \alpha$&lt;/li&gt;
  &lt;li&gt;If $\epsilon \in FIRST(\alpha)$ and $$ \in FOLLOW(A)$ do
      $T[A,$] = \alpha$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**If any entry is multiply defined then $G$ is not LL(1). **&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;not left factored&lt;/li&gt;
  &lt;li&gt;left recursive&lt;/li&gt;
  &lt;li&gt;ambiguous
…&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">1. Intro main topic: parsing methods</summary></entry><entry><title type="html">Constructing Compiler: flex intro</title><link href="http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro/" rel="alternate" type="text/html" title="Constructing Compiler: flex intro " /><published>2018-05-18T00:00:00-07:00</published><updated>2018-05-18T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro/">&lt;h3 id=&quot;heading-flex-intro&quot;&gt;Flex intro&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;flex&lt;/strong&gt; is a tool for generating &lt;strong&gt;scanners&lt;/strong&gt;. This article is my notes for using &lt;strong&gt;flex&lt;/strong&gt;, and most of the material can be found in &lt;a href=&quot;http://westes.github.io/flex/manual/&quot;&gt;website&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* flex syntax */
definitions
%%
rules
%%
user code
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;When the scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, take the longest match token. 
One the match is determined, the text corresponding to the match(&lt;strong&gt;token&lt;/strong&gt;) is made available in the global character pointer &lt;strong&gt;yytext&lt;/strong&gt;, and its length in the global integer &lt;strong&gt;yyleng&lt;/strong&gt;. The &lt;strong&gt;action&lt;/strong&gt; corresponding to the matched pattern is then executed. 
If no match is found, then the default rule is: &lt;strong&gt;the next character in the input is considered matched and copied to the standard ouput.&lt;/strong&gt;
&lt;strong&gt;yytext&lt;/strong&gt; can be defined as a pointer or array
use &lt;code class=&quot;highlighter-rouge&quot;&gt;%pointer&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;%array&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-1-actions&quot;&gt;1. actions&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; %%
[ \t]+        putchar( ' ' );
[ \t]+$       /* ignore this token */
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The action consisting solely of a vertical bar &lt;code class=&quot;highlighter-rouge&quot;&gt;('|')&lt;/code&gt; means &quot;same as the action for the next rule&quot;. 
Actions can include arbitrary C code, including &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; statements to return a value to whatever routine called &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt;. Each time &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt; is called it continues processing tokens from where it last left off until it either reaches the end of the file or executes a return. 
More detailed &lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt; description can be found &lt;a href=&quot;http://westes.github.io/flex/manual/Actions.html#Actions&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-2-generated-scanner&quot;&gt;2. generated scanner&lt;/h3&gt;
&lt;p&gt;output file: &lt;code class=&quot;highlighter-rouge&quot;&gt;lex.yy.c&lt;/code&gt;(includes scanning routine &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt;, symbol table, and macros)
whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt; is called, it scans tokens from the global input file &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt;(which defaults to &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;). It continues until it either reaches an end-of-file or one of its actions executes a &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; statement. 
If the scanner reaches an end-of-file, subsequent calls are undefined unless either &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt; is pointed at a new input file, or &lt;code class=&quot;highlighter-rouge&quot;&gt;yystart()&lt;/code&gt; is called. &lt;code class=&quot;highlighter-rouge&quot;&gt;yystart()&lt;/code&gt; takes one argument, a &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE *&lt;/code&gt; pointer, and initializes &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt; for scanning from that file. 
By default, the scanner uses block-reads rather than simple &lt;code class=&quot;highlighter-rouge&quot;&gt;getc()&lt;/code&gt; calls to read characters from &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt;. This is controlled by defining &lt;code class=&quot;highlighter-rouge&quot;&gt;YY_INPUT&lt;/code&gt; macro. &lt;code class=&quot;highlighter-rouge&quot;&gt;YY_INPUT(buf, result, max_size)&lt;/code&gt;its action is to place up to &lt;code class=&quot;highlighter-rouge&quot;&gt;max_size&lt;/code&gt; characters in the &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt; and return in the integer variable &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%{
 #define YY_INPUT(buf,result,max_size) \
     { \
     int c = getchar(); \
     result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
     }
 %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-3-start-conditions&quot;&gt;3. start conditions&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flex&lt;/code&gt; provides a mechanism for conditionally activating rules. Any rule whose pattern is prefixed with &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sc&amp;gt;&lt;/code&gt; will only be active when the scanner is in the start condition named &lt;code class=&quot;highlighter-rouge&quot;&gt;sc&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;STRING&amp;gt;[^&quot;]* {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;will be active only when the scanner is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING&lt;/code&gt; start condition. 
Start conditions are declared in the definitions section of the input using lines beginning with either &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;(inclusive) or &lt;code class=&quot;highlighter-rouge&quot;&gt;%x&lt;/code&gt;(exclusive). 
A start condition is activated using the &lt;code class=&quot;highlighter-rouge&quot;&gt;BEGIN&lt;/code&gt; action.  If the start condition is inclusive, then rules with no start conditions at all will also be active. If it is exclusive, then only rules qualified with the start condition will be active.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%{
#include &amp;lt;math.h&amp;gt;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&amp;lt;expect&amp;gt;[0-9]+.[0-9]+      {
            printf( &quot;found a float, = %f\n&quot;,
                    atof( yytext ) );
            }
&amp;lt;expect&amp;gt;\n           {
            /* that's the end of the line, so
             * we need another &quot;expect-number&quot;
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {
            printf( &quot;found an integer, = %d\n&quot;,
                    atoi( yytext ) );
            }

&quot;.&quot;         printf( &quot;found a dot\n&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">Flex intro flex is a tool for generating scanners. This article is my notes for using flex, and most of the material can be found in website /* flex syntax */ definitions %% rules %% user code When the scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, take the longest match token. One the match is determined, the text corresponding to the match(token) is made available in the global character pointer yytext, and its length in the global integer yyleng. The action corresponding to the matched pattern is then executed. If no match is found, then the default rule is: the next character in the input is considered matched and copied to the standard ouput. yytext can be defined as a pointer or array use %pointer or %array</summary></entry><entry><title type="html">Lexical Analysis</title><link href="http://localhost:4000/blog/2018/05/10/Lexical-Analysis/" rel="alternate" type="text/html" title="Lexical Analysis " /><published>2018-05-10T00:00:00-07:00</published><updated>2018-05-10T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/10/Lexical%20Analysis</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/10/Lexical-Analysis/">&lt;h2 id=&quot;heading-lexical-analysis&quot;&gt;Lexical Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;goal&lt;/strong&gt;: identify each lexeme and return information on token&lt;/p&gt;
&lt;h3 id=&quot;heading-1-lexical-analyzer-role&quot;&gt;1 Lexical Analyzer Role&lt;/h3&gt;
&lt;p&gt;(1) read input characters, group them into lexemes, and produce output a sequence of tokens&lt;/p&gt;

&lt;p&gt;(2) When the lexical analyzer discovers a lexeme constituting an identifier, it needs to enter that lexeme into the symbol table.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525905998501.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The figure suggests, parser will call lexical analyzer, and lexical analyzer read characters until find next token. 
lexical analyzer will also do some additional jobs:&lt;/p&gt;

&lt;p&gt;(1) strip whitespace&lt;/p&gt;

&lt;p&gt;(2) record line number for error message&lt;/p&gt;
&lt;h4 id=&quot;heading-311-basic-concepts&quot;&gt;3.1.1 Basic Concepts&lt;/h4&gt;
&lt;p&gt;(1) A &lt;strong&gt;token&lt;/strong&gt; is a pair consisting of a token name and an optional attribute value. The token name is an abstract symbol representing a kind of lexical unit.&lt;/p&gt;

&lt;p&gt;(2) A &lt;strong&gt;pattern&lt;/strong&gt; is a description of the form that the lexemes of a token may take. 
the sequence of character which can form keywords&lt;/p&gt;

&lt;p&gt;(3) A &lt;strong&gt;lexeme&lt;/strong&gt; is a sequence of characters in the source program that matches the pattern for a token and is identified by the lexical analyzer as an instance of the token.&lt;/p&gt;

&lt;p&gt;In most programming languages, the following classes cover most or all of the tokens:&lt;/p&gt;

&lt;p&gt;(1) One token for each keyword. The pattern for a keyword is the same as the keyword itself.&lt;/p&gt;

&lt;p&gt;(2) Tokens for the operators&lt;/p&gt;

&lt;p&gt;(3) One token representing all identifiers.&lt;/p&gt;

&lt;p&gt;(4) One or more tokens representing constants&lt;/p&gt;

&lt;p&gt;(5) To kens for each punctuation symbol, such as left and right parentheses, comma, and semicolon.&lt;/p&gt;

&lt;p&gt;Sometimes, token can have different matches, for example, 0 and 1 both match for &lt;strong&gt;number&lt;/strong&gt;. So we not only need token names, we also need token attributes. The token name influences parsing decisions, while the attribute value influences translation of tokens after the parse. 
The appropriate attribute value for an identifier is a pointer to the symbol table entry for that identifier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lexical Errors&lt;/strong&gt; suppose a situation arises in which the lexical analyzer is unable to proceed because none of the patterns for tokens matches any prefix of the remaining input. The simplest recovery strategy is &quot;panic mode&quot; recovery. We delete successive characters from the remaining input, until the lexical analyzer can find a well-formed token at the beginning of what input is left. This recovery technique may confuse the parser, but in an interactive computing environment it may be quite adequate.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-input-buffer&quot;&gt;2 Input Buffer&lt;/h3&gt;
&lt;p&gt;In Dragon book, we can see the example of Fortran language, which justifies the need to look ahead to help tokenize strings.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The goal is to partition the string. This is implemented by reading left-to-right, recognizing one token at a time.&lt;/li&gt;
  &lt;li&gt;&quot;Lookahead&quot; may be required to decide where one token ends and the next token begins. (we want to minimize look ahead)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many situations where we need to look at least one additional character ahead. 
&lt;img src=&quot;/assets/images/1525925908025.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can use a buffer pair to resolve the problem. Each buffer is of the same size N, which is usually the size of a disk block. Using one system read command we can read N characters into a buffer, rather than using one system call per character.&lt;/p&gt;

&lt;p&gt;In the buffer, two pointers are maintained.&lt;/p&gt;

&lt;p&gt;(1) Pointer lexemeBegin, marks the beginning of the current lexeme, whose extent we are attempting to determine.&lt;/p&gt;

&lt;p&gt;(2) Pointer forward scans ahead until a pattern match is found; the exact strategy whereby this determination is made will be covered in the balance of this chapter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525926047058.png&quot; alt=&quot;image&quot; /&gt;
We can add &lt;strong&gt;sentinels&lt;/strong&gt; at the end of each buffer.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (*forward++) {
	case eof: 
		if (forward is at end of first buffer) {
			reload second buffer;
			forward = beginning of second buffer;
		}
		else if (forward is at the end of second buffer) {
			reload first buffer;
			forward = beginning of first buffer;
		}
		else 
			terminate lexical analysis
		break;
	case for other characters;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-3-token-specification&quot;&gt;3 Token Specification&lt;/h3&gt;
&lt;p&gt;We can say lexical structure is a set of token classes. And thus we must say what set of strings is in a token class–&amp;gt; use regular language.&lt;/p&gt;

&lt;p&gt;An &lt;strong&gt;alphabet&lt;/strong&gt; is any finite set of symbols. 
A &lt;strong&gt;string&lt;/strong&gt; over an alphabet is a finite sequence o symbols drawn from the alphabet. 
A &lt;strong&gt;language&lt;/strong&gt; is any countable set of strings over some fixed alphabet. 
meaning function $L$ maps syntax to semantics. 
meaning is many to one.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;operations on language&lt;/strong&gt;
&lt;img src=&quot;/assets/images/1525926320045.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;heading-31-regular-expression&quot;&gt;3.1 Regular Expression&lt;/h4&gt;
&lt;p&gt;We are able to describe identifiers by giving names to sets of letters and digits and using the language operators union, concatenation, and closure. This process is so useful that a notation called &lt;strong&gt;regular expression&lt;/strong&gt; has come into common use for describing all the language that can be built from these operators applied to the symbols of some alphabet.&lt;br /&gt;
Here are the rules that define the regular expressions over some alphabet $\Sigma$ and the languages that those expressions denote. 
There are two rules that form the basis:&lt;/p&gt;

&lt;p&gt;(1) $\epsilon$ is a regular expression, and $L(\epsilon)$ is ${\epsilon}$, that is, the language whose sole member is empty string.&lt;/p&gt;

&lt;p&gt;(2) If $a$ is a symbol in $\Sigma$, then $a$ is a regular expression, and $L(a) = {a}$, that is, the language with one string, of length one, with $a$ in its one position.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525926883438.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525926900662.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;heading-32-extensions-of-regular-expressions&quot;&gt;3.2 Extensions of Regular Expressions&lt;/h4&gt;
&lt;p&gt;(1) One or more instances. &lt;code class=&quot;highlighter-rouge&quot;&gt;(r)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2) Zero or one instance. &lt;code class=&quot;highlighter-rouge&quot;&gt;r?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(3) Character classes &lt;code class=&quot;highlighter-rouge&quot;&gt;[abc]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-4-recognition-of-tokens&quot;&gt;4 Recognition of Tokens&lt;/h3&gt;
&lt;p&gt;Here is our example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stmt -&amp;gt; if expr then stmt
	 | if expr then stmt else stmt
	 |  $\epsilon$
expr -&amp;gt; term relop term
	 | term
term -&amp;gt; id
	 | number 
ws -&amp;gt; (blank | tab | newline)+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525928409876.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;heading-5-finite-automata&quot;&gt;5 Finite Automata&lt;/h3&gt;
&lt;p&gt;The heart of transition is the formalism known as &lt;strong&gt;finite automata&lt;/strong&gt;. 
Finite automata come in two flavors:&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Nondeterministic finite automata&lt;/strong&gt;(NFA) have no restrictions on the labels of their edges. A symbol can label several edges out of the same state, and $\epsilon$, the empty string, is a possible label.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Deterministic finite automata&lt;/strong&gt; (DFA) have, for each state, and for each symbol of its input alphabet exactly one edge with that symbol leaving the state.&lt;/p&gt;

&lt;p&gt;Both deterministic and nondeterministic finite automata are capable of recognizing the same language. In fact these language are exactly the same language, called the &lt;strong&gt;regular language&lt;/strong&gt;, that regular expressions can describe.&lt;/p&gt;
&lt;h4 id=&quot;heading-51-nfa&quot;&gt;5.1 NFA&lt;/h4&gt;
&lt;p&gt;NFA consists of :
(1) A finite set of states $S$&lt;/p&gt;

&lt;p&gt;(2) A set of input symbols $\Sigma$, the input alphabet. We assume that $\epsilon$, which stands for the empty string, is never a member of $\Sigma$&lt;/p&gt;

&lt;p&gt;(3) A transition function that gives, for each state, and for each symbol in $\Sigma \cup{\epsilon}$ a set of next states.&lt;/p&gt;

&lt;p&gt;(4) A state $s_0$ from $S$ that is distinguished as the start state(or initial state)&lt;/p&gt;

&lt;p&gt;(5) A set of states $F$, a subset of $S$, that is distinguished as the accepting states(or final states)&lt;/p&gt;

&lt;p&gt;An NFA &lt;strong&gt;accepts&lt;/strong&gt; input string $x$ iff there is some path in the transition graph from the start state to one of the &lt;strong&gt;accepting states&lt;/strong&gt;, such that the symbols along the path spell out $x$.&lt;/p&gt;
&lt;h4 id=&quot;heading-52-dfa&quot;&gt;5.2 DFA&lt;/h4&gt;
&lt;p&gt;A deterministic finite automata is a special case of an NFA where&lt;/p&gt;

&lt;p&gt;(1) There are no moves on input $\epsilon$&lt;/p&gt;

&lt;p&gt;(2) For each state $s$ and input symbol $a$, there is exactly one edge out of $s$ labeled $a$.&lt;/p&gt;

&lt;p&gt;Every regular expression and every NFA can be converted to a DFA accepting the same language, because it is the DFA that we really implement or simulate when building lexical analyzers.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Simulate a DFA
s = s_0;
c = nextChar();
while (c != eof) {
	s = move(s, c);
	c = nextChar();
}
if (s in Final_state) return &quot;yes&quot;;
else return &quot;no&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-6-regular-expression---automata&quot;&gt;6 Regular Expression -&amp;gt; Automata&lt;/h3&gt;
&lt;h4 id=&quot;heading-61-nfa-dfa&quot;&gt;6.1 NFA-&amp;gt;DFA&lt;/h4&gt;
&lt;p&gt;The general idea behind the subset construction is that each state of the constructed DFA corresponds to a set of NFA states. After reading input $a_1a_2…a_n$, the DFA is in that state which corresponds to the set of states that NFA can reach, from its start state, following paths labeled $a_1a_2…a_n$. 
&lt;img src=&quot;/assets/images/1525974027615.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before reading the first input symbol, N can be in any of the states of $\epsilon-closure(s_0)$. For induction, suppose N can be in set of states $T$ after reading input string $x$. If it next reads input $a$, then $N$ can immediately go to any of the states in $move(T,a)$. However, after reading $a$, it may also make $\epsilon$ transitions. Thus $N$ could be in any state of $\epsilon-closure(move(T,a))$ after reading input $xa$. 
How to construct the set of $D$'s states, $Dstates$, and its transition function $Dtran$. 
Initially, $\epsilon-closure(s_0)$ is the only state in $Dstates$ and it is unmarked.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# construct Dstates and Dtran
while (there is an unmarked state T in Dstates) {
	mark T;
	for (each input symbol a) {
		U  = epsilon-closure(move(T, a));
		if (U is not in Dstates)
			add U as an unmarked state to Dstates;
		Dtran[T,a] = U;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# compute epsilon closure for T
push all states of T onto stack;
initialize epsilon-closure(T) to T;
while (stack is not empty) {
	pop t off the stack;
	for (each state u with an edge from t to u labeled epsilon) {
		if (u is not in epsilon-closure(T)) {
			add u to epsilon-closure(T);
			push u onto stack;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525975686530.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For line 1 and line 4 we can implement a function &lt;code class=&quot;highlighter-rouge&quot;&gt;addState(s)&lt;/code&gt;. This function pushes state $s$ onto &lt;code class=&quot;highlighter-rouge&quot;&gt;newStates&lt;/code&gt;, sets &lt;code class=&quot;highlighter-rouge&quot;&gt;alreadyOn[s]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;, and calls itself recursively on the states in &lt;code class=&quot;highlighter-rouge&quot;&gt;move[s,epsilon]&lt;/code&gt; in order to further the computation of $\epsilon-closure(s)$&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addState(s) {
	push s onto newStates;
	alreadyOn[s] = True;
	for (t on move[s, epsilon])
		if (!alreadyOn(t))
			addState(t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For line 4&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (s on oldStates) {
	for (t on move[s,c]) 
		if (!alreadyOn[t])
			addState(t);
	pop s from oldStates;
}
for (s on newStates) {
	pop s from newStates;
	push s onto oldStates;
	alreadOn[s] = FALSE;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;heading-62-regular-expression---nfa&quot;&gt;6.2 Regular Expression -&amp;gt; NFA&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525976909215.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977147532.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977159550.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977172727.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NFA properties:
(1) $N(r)$ has at most twice as many states as there are operators and operands in $r$. This bound follows the fact that each step of the algorithm creates at most two new states&lt;/p&gt;

&lt;p&gt;(2) $N(r)$ has one start state and one accepting state. The accepting state has no outgoing transitions, and the start has no incoming transitions.&lt;/p&gt;

&lt;p&gt;(3) Each state of $N(r)$ other than the accepting state has either one outgoing transition on a symbol in $\Sigma$ or two outgoing transitions, both on $\epsilon$.&lt;/p&gt;

&lt;h3 id=&quot;heading-7-design-for-a-lexical-generator&quot;&gt;7. Design for a Lexical Generator&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525981672518.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The program that serves as the lexical analyzer includes a fixed program that simulates an automaton. We need a single automation that will recognize lexemes matching any of the patterns in the program, so we combine  all the NFA's into one by introducing a new start state with $\epsilon$-transitions to each of the start states of the NFA's $N_i$.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">Lexical Analysis goal: identify each lexeme and return information on token 1 Lexical Analyzer Role (1) read input characters, group them into lexemes, and produce output a sequence of tokens</summary></entry><entry><title type="html">overview for compiler</title><link href="http://localhost:4000/blog/2018/05/09/overview-for-compiler/" rel="alternate" type="text/html" title="overview for compiler " /><published>2018-05-09T00:00:00-07:00</published><updated>2018-05-09T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/09/overview%20for%20compiler</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/09/overview-for-compiler/">&lt;h2 id=&quot;heading-overview-for-compiler&quot;&gt;overview for compiler&lt;/h2&gt;

&lt;p&gt;analysis part: breaks the source program into constituent pieces and impose a grammatical structure on them and create symbol table  —&amp;gt; &lt;strong&gt;front end&lt;/strong&gt;
synthesis part: constructs the desired target program from the intermediate representation and the information in the symbol table.  –&amp;gt; &lt;strong&gt;back end&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-part-1-lexical-analysis--scanning&quot;&gt;part 1. lexical analysis / scanning&lt;/h3&gt;
&lt;p&gt;scanner reads the character streams making up the source program and groups the characters into meaningful sequences called &lt;strong&gt;lexemes&lt;/strong&gt;. 
For each lexeme, the lexical analyzer produces a &lt;strong&gt;token&lt;/strong&gt; of the form&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&amp;lt;token-name, attribute-value&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;variable names become &lt;strong&gt;id&lt;/strong&gt;–&amp;gt; create symbol table&lt;/p&gt;
&lt;h3 id=&quot;heading-part-2-syntax-analysis&quot;&gt;part 2. syntax analysis&lt;/h3&gt;
&lt;p&gt;This phase is called &lt;strong&gt;syntax analysis&lt;/strong&gt; or &lt;strong&gt;parsing&lt;/strong&gt;. The parser uses the first components of the tokens produced by the lexical analyzer to create a tree-like intermediate representation that depicts the grammatical structure of the token stream.  –&amp;gt; &lt;strong&gt;syntax tree&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-part-3-semantic-analysis&quot;&gt;part 3. semantic analysis&lt;/h3&gt;
&lt;p&gt;The semantic analyzer use the syntax tree and symbol table to check the source program for semantic consistency with the language definition. It also gathers type information and saves it in either the syntax tree or the symbol table, for subsequent use during intermediate-code generation phase. 
&lt;strong&gt;type checking&lt;/strong&gt; happens in this phase.&lt;/p&gt;

&lt;h3 id=&quot;heading-part-4-intermediate-code-generation&quot;&gt;part 4. intermediate code generation&lt;/h3&gt;
&lt;p&gt;use syntax tree to create an explicit low-level or machine-like intermediate representation. &lt;strong&gt;three-address code&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-part-5-code-optimization&quot;&gt;part 5. code optimization&lt;/h3&gt;
&lt;p&gt;The machine-independent code-optimization phase attempts to improve the intermediate code so that better target code will result.&lt;/p&gt;

&lt;h3 id=&quot;heading-part-6-code-generation&quot;&gt;part 6. code generation&lt;/h3&gt;
&lt;p&gt;The code generator takes intermediate code as input and maps it into the target language. The intermediate instructions are translated into sequence of machine instructions that perform the same task.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">overview for compiler</summary></entry><entry><title type="html">Syntax Directed Translator</title><link href="http://localhost:4000/blog/2018/04/22/Syntax-Directed-Translator/" rel="alternate" type="text/html" title="Syntax Directed Translator" /><published>2018-04-22T00:00:00-07:00</published><updated>2018-04-22T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/04/22/Syntax-Directed%20Translator</id><content type="html" xml:base="http://localhost:4000/blog/2018/04/22/Syntax-Directed-Translator/">&lt;h2 id=&quot;heading-syntax-directed-translator&quot;&gt;Syntax-Directed Translator&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;: the proper form of its program -&amp;gt; context-free grammar or BNF(Backus-Naur Form)
&lt;strong&gt;semantic&lt;/strong&gt;: meaning of the program&lt;/p&gt;

&lt;p&gt;goal: syntax-directed translation of infix expressions to postfix form. 
&lt;img src=&quot;/assets/images/1523682572902.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1523682697277.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These are two intermediate representation forms.&lt;/p&gt;

&lt;h3 id=&quot;heading-syntax-definition&quot;&gt;Syntax Definition&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stmt -&amp;gt; if (expr) stmt else stmt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This is one &lt;strong&gt;production&lt;/strong&gt;. In a production, lexical elements like the keyword &lt;strong&gt;if&lt;/strong&gt; and the parentheses are called &lt;strong&gt;terminals&lt;/strong&gt;. Variables like &lt;strong&gt;expr&lt;/strong&gt; and &lt;strong&gt;stmt&lt;/strong&gt; represent sequences of terminals and are called &lt;strong&gt;nonterminals&lt;/strong&gt;. 
&lt;strong&gt;context-free grammar elements&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;A set of terminal symbols(refered as tokens)&lt;/li&gt;
    &lt;li&gt;A set of nonterminals, sometimes called &lt;strong&gt;syntactic variables&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;A set of productions, where each production consists of a nonterminal, called the head or left side of the production, an arrow, and a sequence of terminals and/or nonterminals , called the body or right side of the production&lt;/li&gt;
    &lt;li&gt;A designation of one of the nonterminals as the &lt;strong&gt;start&lt;/strong&gt; symbol.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;heading-derivations&quot;&gt;Derivations&lt;/h4&gt;
&lt;p&gt;A grammar derives strings by beginning with the start symbol and repeatedly replacing a &lt;strong&gt;nonterminal&lt;/strong&gt; by the body of a production for that nonterminal.
example for function call:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call -&amp;gt; id(optparams)
optparams -&amp;gt; params | epsilon
params -&amp;gt; params, param | param
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;epsilon&lt;/code&gt; represents empty string of symbols.&lt;/p&gt;
&lt;h3 id=&quot;heading-parse-trees&quot;&gt;Parse Trees&lt;/h3&gt;
&lt;p&gt;Parsing is the problem of taking a string of terminals and figuring out how to derive it from the start symbol of the grammar.
 &lt;img src=&quot;/assets/images/1523683797606.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From left to right , the leaves of a parse tree form the &lt;strong&gt;yield&lt;/strong&gt; of the tree, which is the string &lt;strong&gt;derived&lt;/strong&gt; from the nonterminal at the root of the parse tree.&lt;/p&gt;
&lt;h3 id=&quot;heading-ambiguity&quot;&gt;Ambiguity&lt;/h3&gt;
&lt;p&gt;A grammar can have more than one parse tree generating a given string of terminals. Such a grammar is said to be &lt;strong&gt;ambiguous&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&quot;heading-operator-assocaitivity&quot;&gt;Operator Assocaitivity&lt;/h4&gt;
&lt;p&gt;Like &lt;code class=&quot;highlighter-rouge&quot;&gt;9 + 5 + 2&lt;/code&gt;, this expression can be evaluated as &lt;code class=&quot;highlighter-rouge&quot;&gt;( 9 + 5 ) + 2&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;9 + (5 + 2)&lt;/code&gt;. We
say that the operator + associates to the left, because an operand with plus signs on both sides of it belongs to the operator to its left.
&lt;strong&gt;left-associative&lt;/strong&gt;: addition, subtraction, multiplication, division
&lt;strong&gt;right-associative&lt;/strong&gt;: equal, exponentiation 
strings like &lt;code class=&quot;highlighter-rouge&quot;&gt;a = b = c&lt;/code&gt; can be generated by rules like&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;right -&amp;gt; letter = right | letter
letter -&amp;gt; a | b | ... | z
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;heading-operator-precedence&quot;&gt;Operator Precedence&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; has higher priority than &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;term -&amp;gt; term * factor
		 | term / factor
		 | factor
expr -&amp;gt; expr + term
		| expr - term
		| term
factor -&amp;gt; digit | (expr)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;factors are expression which cannot be &quot;torn apart“ by any operator. 
Terms is an expression that can be &quot;torn apart&quot; by operators of the higher precedence, but not by the lower precedence operators. 
&lt;img src=&quot;/assets/images/1523684714372.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-syntax-directed-translation&quot;&gt;Syntax-Directed Translation&lt;/h3&gt;
&lt;p&gt;Syntax-directed translation is done by attaching rules or program fragments to productions in a grammar.
&lt;strong&gt;Attributes&lt;/strong&gt; An attribute is any quantity associated with a programming construct. 
Examples of attributes are data types of expressions, the number of instructions in the generated code, or the location of the first instruction in the generated code for a construct , among many other possibilities.
&lt;strong&gt;translation schemes&lt;/strong&gt; A translation scheme is a notation for attaching program fragments to the productions of a grammar. The program fragments are executed when the production is used during syntax analysis.&lt;/p&gt;
&lt;h4 id=&quot;heading-synthesized-attributes&quot;&gt;Synthesized Attributes&lt;/h4&gt;
&lt;p&gt;The idea of associating quantities with programming constructs – for example, values and types with expressions –  can be expressed in terms of grammars. 
A &lt;strong&gt;syntax-directed definition&lt;/strong&gt; associates:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;With each grammar symbol, a set of attributes, and&lt;/li&gt;
  &lt;li&gt;With each production, a set of &lt;strong&gt;semantic rules&lt;/strong&gt; for computing the values of the attributes associated with the symbols appearing in the production.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1523687837245.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1523688227467.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The string representing the translation of the nonterminal at the head of each production is the concatenation of the translations of the nonterminals in the production body, in the same order as in the production, with some optional additional strings interleaved.
&lt;img src=&quot;/assets/images/1523816009378.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tree traversals&lt;/strong&gt; will be used for describing attribute evaluation and for specifying the execution of code fragments in a translation scheme.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DFS
procedure visit(N) {
	for (each child of N, from left to right) {
		visit(child);
	}
	evaluate rule at N;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If the action is done when we first visit a node, then we may refer to the traversal as a preorder traversal. Similarly, if the action is done just before we leave a node for the last time, then we say it is a postorder traversal of the tree.
A &lt;strong&gt;syntax-directed translation&lt;/strong&gt;  scheme is a notation for specifying a translation by attaching program fragments to productions in a grammar.
&lt;strong&gt;the order of evaluation of the semantic rules is explicitly specified&lt;/strong&gt;
Program fragments embedded within production bodies are called &lt;strong&gt;semantic actions&lt;/strong&gt;. The position at which an action is to be executed is shown by enclosing it between curly braces and writing it within the production body&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rest -&amp;gt; + term {print('+') } rest1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1523817208488.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-parsing&quot;&gt;Parsing&lt;/h3&gt;
&lt;p&gt;Parsing is the process of determining how a string of terminals can be generated by a grammar. 
Parsing techniques : &quot;top-down&quot;, &quot;bottom-up&quot;&lt;/p&gt;
&lt;h4 id=&quot;heading-top-down-parsing&quot;&gt;Top-Down Parsing&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1523817869025.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;At node N, labeled with nonterminal A, select one of the productions for A and construct children at N for the symbols in the production body.&lt;/li&gt;
  &lt;li&gt;Find the next node at which a subtree is to be constructed, typically the leftmost unexpanded nonterminal of the tree.
This method requires trail and error, and backtracking. May not be a good candidate
    &lt;h4 id=&quot;heading-predictive-parsing&quot;&gt;Predictive Parsing&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;recursive-descent parsing&lt;/strong&gt; is a top-down approach. Here we consider one simple version–predictive parsing:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;The sequence of procedure calls during the analysis of an input string implicitly defines a parse tree for the input&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void stmt () {
	switch ( lookahead ) {
	case expr:
		match (expr) ; match (' ; ') ; break;
	case if:
		match (if) ; match (' C'); match (expr) ; match (' ) ') ; stmt O ;
		break;
	case for:
		match (for) ; match (' C');
		optexpr O ; match (' ; ') ; optexprO ; match (' ; ') ; optexprO ;
		match (' ) ') ; stmt O ; break;
	case other;
		match (other) ; break;
	default:
		report ( &quot; syntax error &quot; );
}
void optexpr() {
	if ( lookahead = = expr ) match (expr) ;
}
void match (terminal t) {
	if ( lookahead = = t ) lookahead = nextTerminal;
	else report ( &quot; syntax error &quot; );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Predictive parsing relies on information about the first symbols that can be generated by a production body. Our predictive parser uses an E-production as a default when no other production
can be used.&lt;/p&gt;

&lt;p&gt;let $\alpha$ be a string of grammar symbols (terminals and/or nonterminals). We define First($\alpha$) to be the set of terminals that appear as the first symbols of one or more strings of terminal generated from $\alpha$.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FIRST ( stmt) = { expr, if, for, other}
FIRST( expr ; ) = {expr}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;A predictive parser is a program consisting of a procedure for every nonterminal. The procedure fot nonterminal A does two things:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;It decides which A-production to use by examining the lookahead symbol. The production with body $\alpha$is used if the lookahead symbol is in FIRST ($\alpha$) .&lt;/li&gt;
  &lt;li&gt;The procedure then mimics the body of the chosen production.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;heading-left-recursion&quot;&gt;Left-recursion&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expr -&amp;gt; expr + term
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It's possible for a recursive-descent parser to loop forever if the leftmost symbol is the same as head. Since the lookahead symbol changes only when a terminal in the body is matched, no change to the input took place between recursive calls of &lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A -&amp;gt; A$\alpha$ | $\beta$
can be replaced by 
A -&amp;gt; $\beta$R
R -&amp;gt; $\alpha$R | $\epsilon$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first one is left-recursive, the second is right-recursive. But right recursive makes it hard to translate left-associate operators. 
&lt;img src=&quot;/assets/images/1523820504263.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">Syntax-Directed Translator syntax: the proper form of its program -&amp;gt; context-free grammar or BNF(Backus-Naur Form) semantic: meaning of the program</summary></entry></feed>
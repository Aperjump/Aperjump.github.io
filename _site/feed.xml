<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.4.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-09-15T16:44:14-07:00</updated><id>http://localhost:4000/</id><title type="html">Aperjump's Playground</title><subtitle>Embrace your inner geek.</subtitle><author><name>Wang Wei</name></author><entry><title type="html">TimeStamp Ordering Concurrency Control</title><link href="http://localhost:4000/blog/2018/09/15/TimeStamp-Ordering/" rel="alternate" type="text/html" title="TimeStamp Ordering Concurrency Control" /><published>2018-09-15T00:00:00-07:00</published><updated>2018-09-15T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/09/15/TimeStamp-Ordering</id><content type="html" xml:base="http://localhost:4000/blog/2018/09/15/TimeStamp-Ordering/">&lt;h2 id=&quot;heading-timestamp-ordering-concurrency-control&quot;&gt;TimeStamp Ordering Concurrency Control&lt;/h2&gt;
&lt;h3 id=&quot;heading-concurrency-control-approaches&quot;&gt;Concurrency Control Approaches&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Two-phase Locking(2PL)
Determine serializability order of conflicting operations at runtime while txns execute &lt;strong&gt;Pessimistic&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Timestamp Ordering(T/O)
Determine serializability order of txns before they execute &lt;strong&gt;Optimistic&lt;/strong&gt;
    &lt;h4 id=&quot;heading-to-concurrency-control&quot;&gt;T/O Concurrency Control&lt;/h4&gt;
    &lt;p&gt;Use timestamps to determine the serializability order of txns
if &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; TS(T_j)&lt;/code&gt;, then the DBMS must ensure that the execution schedule is equivalent to a serial schedule where &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; appears before &lt;code class=&quot;highlighter-rouge&quot;&gt;T_j&lt;/code&gt;.&lt;/p&gt;
    &lt;h4 id=&quot;heading-timestamp-allocation&quot;&gt;Timestamp Allocation&lt;/h4&gt;
    &lt;p&gt;Each txn &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; is assigned a unique fixed timestamp that is &lt;strong&gt;monotonically increasing&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Let &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i)&lt;/code&gt; be the timestamp allocated to txn &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Different schemes assign timestamps at different times during the txn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Multiple implementation strategies&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;System Clock&lt;/li&gt;
  &lt;li&gt;Logical Counter&lt;/li&gt;
  &lt;li&gt;Hybrid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Agenda&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Basic Timestamp Ordering&lt;/li&gt;
  &lt;li&gt;Optimistic Concurrency Control&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;heading-basic-to&quot;&gt;Basic T/O&lt;/h4&gt;
&lt;p&gt;Txns read and write objects without locks
Every object &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is tagged with timestamp of the last txn that successfully did read/write:
&lt;code class=&quot;highlighter-rouge&quot;&gt;W-TX(X)&lt;/code&gt; - Write timestamp on &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;R-TX(X)&lt;/code&gt; - Read timestamp on &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;
We need to check timestamps for every operation:
if txn tries to access an object &quot;from the future&quot;, it aborts and restart.&lt;/p&gt;

&lt;h5 id=&quot;heading-reads&quot;&gt;Reads&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;W-TS(X)&lt;/code&gt; means the last write transaction on object &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;. 
If &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; W-TS(X)&lt;/code&gt;, this violates timestamp order of &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; with regard to the writer of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;(read into the future)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abort &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; and restart it with same TS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Else:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allow &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; to read &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Update &lt;code class=&quot;highlighter-rouge&quot;&gt;R-TS(X)&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;max(R-TS(X), TS(T_i))&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Have to make a local copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; to ensure repeatable reads for &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;heading-writes&quot;&gt;Writes&lt;/h5&gt;
&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; R-TS(X)&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; W-TS(X)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abort and restart &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Else:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allow &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; to write &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and update &lt;code class=&quot;highlighter-rouge&quot;&gt;W-TS(X)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Also have to make a local copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; to ensure repeatable reads for &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;heading-thomas-write-rule&quot;&gt;Thomas Write Rule&lt;/h4&gt;
&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; R-TS(X)&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abort and restart &lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt;
If &lt;code class=&quot;highlighter-rouge&quot;&gt;TS(T_i) &amp;lt; W-TS(X):
-&amp;gt; **Thomas Write Rule** : Ignore the write and allow the txn to continue
This violates timestamp order of &lt;/code&gt;T_i&lt;code class=&quot;highlighter-rouge&quot;&gt;
Else:
-&amp;gt; Allow &lt;/code&gt;T_i&lt;code class=&quot;highlighter-rouge&quot;&gt; to write &lt;/code&gt;X&lt;code class=&quot;highlighter-rouge&quot;&gt; and update &lt;/code&gt;W-TS(X)`&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basic Timestamp Ordering will generate a schedule that is conflict serializable if you do &lt;strong&gt;not&lt;/strong&gt; use the Thomas Write Rule&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No deadlocks because no txn ever waits&lt;/li&gt;
  &lt;li&gt;possibility of starvation for &lt;strong&gt;long txns&lt;/strong&gt; if short txns keep causing conflicts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Permits schedules that are not &lt;strong&gt;recoverable&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-recoverable-schedules&quot;&gt;Recoverable Schedules&lt;/h3&gt;
&lt;p&gt;A schedule is &lt;strong&gt;recoverable&lt;/strong&gt; if txns commit only after all txns whose changes they read, commit. 
Otherwise, the DBMS cannot guarantee that txns read data that will restored after recovering from a crash. 
&lt;img src=&quot;/assets/images/1537048174787.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;heading-basic-io-performance-issues&quot;&gt;Basic I/O Performance Issues&lt;/h3&gt;
&lt;p&gt;High overhead from copying data to txn's workspace and from updating timestamps
long running txns can get starved.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The likelihood that a txn will read something from a newer txn increases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Suffers from timestamp bottleneck.&lt;/p&gt;

&lt;p&gt;If you assume that conflicts between txns are &lt;strong&gt;rare&lt;/strong&gt; and that most txns are &lt;strong&gt;short-lived&lt;/strong&gt;, then forcing txns to wait to acquire locks adds a lot of overhead. A better approach is to optimize for no-conflict case.&lt;/p&gt;
&lt;h3 id=&quot;heading-optimistic-concurrency-control&quot;&gt;Optimistic Concurrency Control&lt;/h3&gt;
&lt;p&gt;The DBMS creates a private workspace for each txn. 
-&amp;gt; All modifications are applied to workspace
-&amp;gt; Any object read is copied into workspace&lt;/p&gt;

&lt;p&gt;When a txn commits, the DBMS compares its workspace write set to see whether it conflicts with other txns
If there are no conflicts, the write set is installed into the &quot;global&quot; database. 
OCC Phases:
(1) read phase:
track the read/write sets of txns and store their writes in a private workspace
(2) validation phase:
when a txn commits, check whether it conflicts with other txns
(3) write phase:
If validation succeeds, apply private changes to database. Otherwise abort and restart the txn.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Txns do not have a timestamp until they enter validation phase&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;heading-occ---validation-phase&quot;&gt;OCC - Validation Phase&lt;/h5&gt;
&lt;p&gt;The DBMS needs to guarantee only serializable schedules are permitted
&lt;code class=&quot;highlighter-rouge&quot;&gt;T_i&lt;/code&gt; checks other txns for RW and WW conflicts and makes sure that all conflicts go one way(from older txns to younger txns)&lt;/p&gt;

&lt;p&gt;We need to execute &lt;strong&gt;Validation&lt;/strong&gt; and &lt;strong&gt;Write&lt;/strong&gt; phase inside a protected critical section.&lt;/p&gt;

&lt;p&gt;When to use OCC
When number of conflicts is low.:
-&amp;gt; All txns are read-only
-&amp;gt; Txns access disjoint subsets of data&lt;/p&gt;

&lt;p&gt;If the database is large and the workload is not skewed, then there is a low probability of conflict, so again locking is wasteful.&lt;/p&gt;

&lt;p&gt;When a txn commits, all previous T/O schemes check to see whether there is a conflict with concurrent txns.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;This requires latches&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a lot of concurrent txns, then this is slow even if the conflict rate is low.&lt;/p&gt;
&lt;h3 id=&quot;heading-partition-based-to&quot;&gt;Partition-Based T/O&lt;/h3&gt;
&lt;p&gt;Split the database up in disjoint subsets called &lt;strong&gt;partitions&lt;/strong&gt;(aka shards)
Only check for conflicts between txns that are running in the same partition. 
&lt;img src=&quot;/assets/images/1537050396631.png&quot; alt=&quot;Alt text&quot; /&gt;
Txns are assigned timestamps based on when they arrive at the DBMS
Partitions are protected by a single lock:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;each txn is queued at the partitions it needs&lt;/li&gt;
  &lt;li&gt;The txn acquires a partitions's lock if it has the lowest timestamp in that partition's queue&lt;/li&gt;
  &lt;li&gt;The txn starts when it has all of the locks for all the partitions that it will read/write&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Partition-based T/O protocol is very fast if:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The DBMS knows what partitions the txn needs before it starts&lt;/li&gt;
  &lt;li&gt;Most(if not all) txns only need to access a single partition&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Multi-partition txns causes partitions to be idle while txn executes.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Database" /><summary type="html">TimeStamp Ordering Concurrency Control Concurrency Control Approaches Two-phase Locking(2PL) Determine serializability order of conflicting operations at runtime while txns execute Pessimistic Timestamp Ordering(T/O) Determine serializability order of txns before they execute Optimistic T/O Concurrency Control Use timestamps to determine the serializability order of txns if TS(T_i) &amp;lt; TS(T_j), then the DBMS must ensure that the execution schedule is equivalent to a serial schedule where T_i appears before T_j. Timestamp Allocation Each txn T_i is assigned a unique fixed timestamp that is monotonically increasing Let TS(T_i) be the timestamp allocated to txn T_i Different schemes assign timestamps at different times during the txn.</summary></entry><entry><title type="html">Advanced DB Quert Compilation</title><link href="http://localhost:4000/blog/2018/09/15/Query-Compilation/" rel="alternate" type="text/html" title="Advanced DB Quert Compilation" /><published>2018-09-15T00:00:00-07:00</published><updated>2018-09-15T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/09/15/Query-Compilation</id><content type="html" xml:base="http://localhost:4000/blog/2018/09/15/Query-Compilation/">&lt;h2 id=&quot;heading-advanced-db-query-compilation&quot;&gt;Advanced DB Query Compilation&lt;/h2&gt;
&lt;p&gt;Agenda:
code generation
JIT compilation&lt;/p&gt;

&lt;p&gt;When switch to an in-memory DBMS, the only way to increase the throughput is to reduce the number of instructions executed. 
One way to achieve such a reduction in instructions is through &lt;strong&gt;code specialization&lt;/strong&gt;. This means generating code that is specific to a particular task in the DBMS.&lt;/p&gt;

&lt;h3 id=&quot;heading-query-processing-model&quot;&gt;Query Processing Model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Tuple at a time&lt;/li&gt;
  &lt;li&gt;Operator at a time(Materialization model)-&amp;gt; good for OLTP&lt;/li&gt;
  &lt;li&gt;vector at a time (batch materialization)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;where B.val = ? + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We need to look at the schema to lookup B's val value type. 
Current Tuple -&amp;gt; Query Parameters -&amp;gt; Table Schema
This is an expensive operation.&lt;/p&gt;

&lt;p&gt;Any CPU intensive entity of database can be natively compiled if they have a similar execution pattern on different inputs.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;access methods&lt;/li&gt;
  &lt;li&gt;stored procedures&lt;/li&gt;
  &lt;li&gt;operator execution&lt;/li&gt;
  &lt;li&gt;predicate evaluation&lt;/li&gt;
  &lt;li&gt;logging operation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benefits&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Attribute types are known &lt;strong&gt;a priori&lt;/strong&gt;
Data access function calls can be converted to inline pointer casting&lt;/li&gt;
  &lt;li&gt;Predicates are known &lt;strong&gt;a priori&lt;/strong&gt;
They can be evaluated using primitive data comparisons&lt;/li&gt;
  &lt;li&gt;No function calls in loops
Allows the compiler to efficiently distribute data to registers and increase cache reuse.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1537027143114.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-code-generation&quot;&gt;Code Generation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Approach 1: Transpilation
Write code that converts a relational query plan into C/C++ and then run it through a conventional compiler to generate native code&lt;/li&gt;
  &lt;li&gt;Approach 2: JIT Compilation
Generate an &lt;strong&gt;intermediate representation&lt;/strong&gt; of they query that can be quickly compiled into native code&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;heading-transpilation&quot;&gt;Transpilation&lt;/h4&gt;
&lt;p&gt;For a given query plan, create a C/C++ program
that implements that query’s execution.
→ Bake in all the predicates and type conversions&lt;/p&gt;

&lt;p&gt;Use an off-shelf compiler to convert the code into
a shared object, link it to the DBMS process, and
then invoke the exec function.&lt;/p&gt;

&lt;p&gt;Relational operators are a useful way to reason about a query but are not the most efficient way to execute it. 
It takes a long time to compile a C/C++ source file into executable code.&lt;/p&gt;

&lt;h4 id=&quot;heading-pipelined-operator&quot;&gt;Pipelined Operator&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1537028381129.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-jit-query-compilation&quot;&gt;JIT Query Compilation&lt;/h3&gt;
&lt;p&gt;Compile queries in-memory into native code using
the LLVM toolkit.
Organizes query processing in a way to keep a
tuple in CPU registers for as long as possible.
→ Push-based vs. Pull-based
→ Data Centric vs. Operator Centric&lt;/p&gt;

&lt;p&gt;LLVM
Collection of modular and reusable compiler and toolchain technologies
Core component is a low-level programming language(IR) that is similar to assembly. 
Not all of the DBMS components need to written in LLVM IR.&lt;/p&gt;

&lt;h3 id=&quot;heading-query-compilation-cost&quot;&gt;Query Compilation Cost&lt;/h3&gt;
&lt;p&gt;LLVM's compilation time grows super-linearly relative to the query size. 
Solution:&lt;strong&gt;Adaptive Execution&lt;/strong&gt;
First generate the LLVM IR for the query. Then execute that IR in an interpreter. Compile the query in the background. 
When the compiled query is ready, seamlessly replace the interpretive execution. 
&lt;img src=&quot;/assets/images/1537031357631.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Database" /><summary type="html">Advanced DB Query Compilation Agenda: code generation JIT compilation</summary></entry><entry><title type="html">How to debug a multi-thread program</title><link href="http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program/" rel="alternate" type="text/html" title="How to debug a multi-thread program" /><published>2018-09-04T00:00:00-07:00</published><updated>2018-09-04T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program</id><content type="html" xml:base="http://localhost:4000/blog/2018/09/04/How-to-debug-a-multithread-program/">&lt;h2 id=&quot;heading-how-to-debug-a-multi-thread-program&quot;&gt;How to debug a multi-thread program.&lt;/h2&gt;
&lt;p&gt;This passage will discuss the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt; for multi-threading program debug. You can find my code on my github &lt;a href=&quot;https://github.com/Aperjump/blog_code/tree/master/How-to-degbug-A-multithreaded-program&quot;&gt;code&lt;/a&gt;
The code implements a simple producer-consumer pattern written in C, and use &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread&lt;/code&gt; to create new threads. Although you can compile it without any problem, there are four bugs in the code and our mission is to find them all using &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;heading-lldb&quot;&gt;lldb&lt;/h3&gt;
&lt;p&gt;For &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; users, some commands may different, but there is a command transformation &lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot;&gt;table&lt;/a&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;heading-basic-commands&quot;&gt;Basic Commands&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# set breakpoint for xx function
(lldb)breakpoint set -name xx
# set breakpoint for method in class
(lldb)breakpoint set -method xx
# set breakpoint in file F line L
(lldb)breakpoint set -file F -line L
# set breakpoint in function address
(lldb)breakpoint set -a funcaddr
# list all breakpoints
(lldb)breakpoint list
# delete break point
(lldb)breakpoint delete index
------------------------------
# run
(lldb)r
# next
(lldb)n
# step int
(lldb)s
# step out
(lldb)f
# continue
(lldb)c
------------------------------
# watch some variable change when written
(lldb)watchpoint set variable val
------------------------------
# variable in current frame
(lldb)frame variable
(lldb)fr v
# print variable
(lldb)p val
------------------------------
# find all frames
(lldb)thread backtrace all
(lldb)bt all
# current frame
(lldb)thread backtrace
(lldb)bt
# select frame X
(lldb)frame select X
# thread in current frame
(lldb)thread list
# select thread X
(lldb)thread select X
----------------------------
# evaluate a expression E
(lldb)expression E
(lldb)e E
# note expression can be used to dynamically change a value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt; share most commands with &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;. 
Note : Although &lt;code class=&quot;highlighter-rouge&quot;&gt;watchpoint&lt;/code&gt; seems like a powerful tool, it's rather limited. On my MacBook Pro(x86_64), there are only 4 hardware watchpoint registers, each at most 8 bytes. So there can be only 48 byte range support. If you read the code, the most important structure is &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_t&lt;/code&gt;, since it includes one &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_lock&lt;/code&gt;, which is 64 bytes, &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_t&lt;/code&gt; cannot fit in our watchlist registers.&lt;/p&gt;
&lt;h3 id=&quot;heading-program&quot;&gt;program&lt;/h3&gt;
&lt;p&gt;(1) Failed to join producer thread: Invalid argument
If we run the program without any modification, we will get this error. So why does this happen? 
Jumping into the code&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x000000010000178e producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:72
   69     /* Join threads, handle return values where appropriate */
   70
   71     result = pthread_join(producer_thread, NULL);
-&amp;gt; 72     if (0 != result) {
   73       fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result));
   74       pthread_exit(NULL);
   75     }
Target 0: (producer_consumer) stopped.
(lldb) p result
(int) $3 = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Here we can see &lt;code class=&quot;highlighter-rouge&quot;&gt;result=3&lt;/code&gt;, indicates we are trying to join a thread which doesn't exist. If we print &lt;code class=&quot;highlighter-rouge&quot;&gt;g_num_prod&lt;/code&gt;, it returns 1, meaning that our &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt; has not stopped (only producer_routine will change &lt;code class=&quot;highlighter-rouge&quot;&gt;g_num_prod&lt;/code&gt; value).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) bt all
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x000000010000177d producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:71
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
  thread #2
    frame #0: 0x00007fff721f1306 libsystem_kernel.dylib`swtch_pri + 10
    frame #1: 0x00007fff723c322e libsystem_pthread.dylib`sched_yield + 11
    frame #2: 0x0000000100001ae4 producer_consumer`producer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:133
    frame #3: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #4: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #5: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100001c39 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:172
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #4
    frame #0: 0x00007fff721fb2ba libsystem_kernel.dylib`__write_nocancel + 10
    frame #1: 0x00007fff7213c796 libsystem_c.dylib`_swrite + 87
    frame #2: 0x00007fff721353bd libsystem_c.dylib`__sflush + 87
    frame #3: 0x00007fff72137aa8 libsystem_c.dylib`__sfvwrite + 816
    frame #4: 0x00007fff72141738 libsystem_c.dylib`__vfprintf + 16158
    frame #5: 0x00007fff72166059 libsystem_c.dylib`__v2printf + 473
    frame #6: 0x00007fff7213d742 libsystem_c.dylib`vfprintf_l + 54
    frame #7: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #8: 0x0000000100001b4a producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:148
    frame #9: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #10: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #11: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We can see just before &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt; there are still 4 frames. The reason here is the use of &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_detach()&lt;/code&gt; will make a thread cannot join.&lt;/p&gt;

&lt;p&gt;(2) Segment Fault
After the first modification, my program will block at&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) n
Process 64207 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100000846 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:82
   79       fprintf(stderr, &quot;Failed to join consumer thread: %s\n&quot;, strerror(result));
   80       pthread_exit(NULL);
   81     }
-&amp;gt; 82     printf(&quot;\nPrinted %lu characters.\n&quot;, *(long*)thread_return);
   83     free(thread_return);
   84
   85     pthread_mutex_destroy(&amp;amp;queue.lock);
Target 0: (producer_consumer) stopped.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If we evaluate expression &lt;code class=&quot;highlighter-rouge&quot;&gt;*(long*)thread_return&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) e *(long*)thread_return
error: Couldn't apply expression side effects : Couldn't dematerialize a result variable: couldn't read its memory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Meaning that return variable in &lt;code class=&quot;highlighter-rouge&quot;&gt;customer_routine&lt;/code&gt; has some problem. If we look at source code, the return variable &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; is actually a local variable. We need to change it to heap space.&lt;/p&gt;

&lt;p&gt;(3) Segment Fault (2)
At this time, if you run the program, we will find some time the program runs correctly, but sometimes, it fall back to segment fault.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Process 80389 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
   70     /* Join threads, handle return values where appropriate */
   71
   72     result = pthread_join(producer_thread, NULL);
-&amp;gt; 73     if (0 != result) {
   74       fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result));
   75       pthread_exit(NULL);
   76     }
Target 0: (producer_consumer) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
(lldb) bt all
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
  * frame #0: 0x0000000100000778 producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:73
    frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1
    frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1
  thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100000c54 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:174
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
  thread #4
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
    frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83
    frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253
    frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31
    frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28
    frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187
    frame #6: 0x0000000100000c54 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:174
    frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340
    frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377
    frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;After joining &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt;, we investigate current stack state. It can be seen there are current three threads executing, and we can change to thread 3.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) thread select 3
* thread #3
    frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10
libsystem_kernel.dylib`__psynch_mutexwait:
-&amp;gt;  0x7fff721faa46 &amp;lt;+10&amp;gt;: jae    0x7fff721faa50            ; &amp;lt;+20&amp;gt;
    0x7fff721faa48 &amp;lt;+12&amp;gt;: movq   %rax, %rdi
    0x7fff721faa4b &amp;lt;+15&amp;gt;: jmp    0x7fff721f1ae9            ; cerror_nocancel
    0x7fff721faa50 &amp;lt;+20&amp;gt;: retq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;These are assembly code, since our problem is linked to &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread.h&lt;/code&gt;, those program has been compiled. Here we need to jump to our code frame. 
Program will stop on this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) n
Process 90312 stopped
* thread #4, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000100000c21 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:170
   167        else
   168          queue_p-&amp;gt;front-&amp;gt;next-&amp;gt;prev = NULL;
   169
-&amp;gt; 170        queue_p-&amp;gt;front = queue_p-&amp;gt;front-&amp;gt;next;
   171        pthread_mutex_unlock(&amp;amp;queue_p-&amp;gt;lock);
   172
   173        /* Print the character, and increment the character count */
Target 0: (producer_consumer) stopped.
(lldb) e queue_p-&amp;gt;front
(queue_node_s *) $0 = 0x0000000100600020
(lldb) e queue_p-&amp;gt;front-&amp;gt;next
(queue_node_s *) $1 = 0x0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Apparently, some other thread steals &lt;code class=&quot;highlighter-rouge&quot;&gt;queue_p-&amp;gt;front-&amp;gt;next&lt;/code&gt; away, we need to add another lock at the end of each loop. 
(4) Modify Global Variable
The third problem has nothing to do with &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;. When modifying global variable in a thread, we need use mutex to protect it, the change is made in &lt;code class=&quot;highlighter-rouge&quot;&gt;producer_routine&lt;/code&gt;.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="lldb" /><category term="Debug" /><summary type="html">How to debug a multi-thread program. This passage will discuss the usage of lldb for multi-threading program debug. You can find my code on my github code The code implements a simple producer-consumer pattern written in C, and use pthread to create new threads. Although you can compile it without any problem, there are four bugs in the code and our mission is to find them all using lldb. lldb For gdb users, some commands may different, but there is a command transformation table between gdb and lldb. Basic Commands # set breakpoint for xx function (lldb)breakpoint set -name xx # set breakpoint for method in class (lldb)breakpoint set -method xx # set breakpoint in file F line L (lldb)breakpoint set -file F -line L # set breakpoint in function address (lldb)breakpoint set -a funcaddr # list all breakpoints (lldb)breakpoint list # delete break point (lldb)breakpoint delete index ------------------------------ # run (lldb)r # next (lldb)n # step int (lldb)s # step out (lldb)f # continue (lldb)c ------------------------------ # watch some variable change when written (lldb)watchpoint set variable val ------------------------------ # variable in current frame (lldb)frame variable (lldb)fr v # print variable (lldb)p val ------------------------------ # find all frames (lldb)thread backtrace all (lldb)bt all # current frame (lldb)thread backtrace (lldb)bt # select frame X (lldb)frame select X # thread in current frame (lldb)thread list # select thread X (lldb)thread select X ---------------------------- # evaluate a expression E (lldb)expression E (lldb)e E # note expression can be used to dynamically change a value lldb share most commands with gdb. Note : Although watchpoint seems like a powerful tool, it's rather limited. On my MacBook Pro(x86_64), there are only 4 hardware watchpoint registers, each at most 8 bytes. So there can be only 48 byte range support. If you read the code, the most important structure is queue_t, since it includes one pthread_mutex_lock, which is 64 bytes, queue_t cannot fit in our watchlist registers. program (1) Failed to join producer thread: Invalid argument If we run the program without any modification, we will get this error. So why does this happen? Jumping into the code * thread #1, queue = 'com.apple.main-thread', stop reason = step over frame #0: 0x000000010000178e producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:72 69 /* Join threads, handle return values where appropriate */ 70 71 result = pthread_join(producer_thread, NULL); -&amp;gt; 72 if (0 != result) { 73 fprintf(stderr, &quot;Failed to join producer thread: %s\n&quot;, strerror(result)); 74 pthread_exit(NULL); 75 } Target 0: (producer_consumer) stopped. (lldb) p result (int) $3 = 3 Here we can see result=3, indicates we are trying to join a thread which doesn't exist. If we print g_num_prod, it returns 1, meaning that our producer_routine has not stopped (only producer_routine will change g_num_prod value). (lldb) bt all * thread #1, queue = 'com.apple.main-thread', stop reason = step over * frame #0: 0x000000010000177d producer_consumer`main(argc=1, argv=0x00007ffeefbff548) at producer_consumer.c:71 frame #1: 0x00007fff720aa015 libdyld.dylib`start + 1 frame #2: 0x00007fff720aa015 libdyld.dylib`start + 1 thread #2 frame #0: 0x00007fff721f1306 libsystem_kernel.dylib`swtch_pri + 10 frame #1: 0x00007fff723c322e libsystem_pthread.dylib`sched_yield + 11 frame #2: 0x0000000100001ae4 producer_consumer`producer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:133 frame #3: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #4: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #5: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13 thread #3 frame #0: 0x00007fff721faa46 libsystem_kernel.dylib`__psynch_mutexwait + 10 frame #1: 0x00007fff723c2b9d libsystem_pthread.dylib`_pthread_mutex_lock_wait + 83 frame #2: 0x00007fff723c04c8 libsystem_pthread.dylib`_pthread_mutex_lock_slow + 253 frame #3: 0x00007fff72134cfa libsystem_c.dylib`flockfile + 31 frame #4: 0x00007fff7213d728 libsystem_c.dylib`vfprintf_l + 28 frame #5: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187 frame #6: 0x0000000100001c39 producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:172 frame #7: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #8: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #9: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start + 13 thread #4 frame #0: 0x00007fff721fb2ba libsystem_kernel.dylib`__write_nocancel + 10 frame #1: 0x00007fff7213c796 libsystem_c.dylib`_swrite + 87 frame #2: 0x00007fff721353bd libsystem_c.dylib`__sflush + 87 frame #3: 0x00007fff72137aa8 libsystem_c.dylib`__sfvwrite + 816 frame #4: 0x00007fff72141738 libsystem_c.dylib`__vfprintf + 16158 frame #5: 0x00007fff72166059 libsystem_c.dylib`__v2printf + 473 frame #6: 0x00007fff7213d742 libsystem_c.dylib`vfprintf_l + 54 frame #7: 0x00007fff7213b7cb libsystem_c.dylib`printf + 187 frame #8: 0x0000000100001b4a producer_consumer`consumer_routine(arg=0x00007ffeefbff4c8) at producer_consumer.c:148 frame #9: 0x00007fff723c2661 libsystem_pthread.dylib`_pthread_body + 340 frame #10: 0x00007fff723c250d libsystem_pthread.dylib`_pthread_start + 377 frame #11: 0x00007fff723c1bf9 libsystem_pthread.dylib`thread_start We can see just before pthread_join there are still 4 frames. The reason here is the use of pthread_detach() will make a thread cannot join.</summary></entry><entry><title type="html">Dynamic Programming</title><link href="http://localhost:4000/blog/2018/06/02/dynamic_programming/" rel="alternate" type="text/html" title="Dynamic Programming" /><published>2018-06-02T00:00:00-07:00</published><updated>2018-06-02T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/06/02/dynamic_programming</id><content type="html" xml:base="http://localhost:4000/blog/2018/06/02/dynamic_programming/">&lt;h2 id=&quot;heading-dynamic-programming&quot;&gt;Dynamic Programming&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;空间优化&lt;/li&gt;
  &lt;li&gt;局部优化和全局最优实现时间优化&lt;/li&gt;
  &lt;li&gt;记忆化搜索&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;动态规划的4要点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态
a) 最优解/Max/Min
b) Yes/No
c) Count(*)&lt;/li&gt;
  &lt;li&gt;方程(状态之间的联系)&lt;/li&gt;
  &lt;li&gt;初始化&lt;/li&gt;
  &lt;li&gt;答案&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态规划的空间规划
House Robber
&lt;a href=&quot;https://www.lintcode.com/problem/house-robber/description&quot;&gt;website&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;状态&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt; 表示前i个房子中，偷到的最大价值&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i] = max(f[i-1], f[i-2]+A[i])&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[0] = A[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f[1] = max(A[0],A[1])&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f[n-1]&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一维优化特点&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;是由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i-1]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i-2]&lt;/code&gt;决定，这样可以转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i%2]&lt;/code&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-1)%2]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-2)%2]&lt;/code&gt;决定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态state
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i]&lt;/code&gt;表示前i个方子中，&lt;strong&gt;偷了第i个房子的&lt;/strong&gt;，偷到的最大价值&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i] = max(f[i-2], f[i-3]) + A[i]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[0] = A[0]; f[1] = A[1]; f[2] = A[0] + A[2];&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;max{f[i]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i%3]&lt;/code&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-2)%3]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;f[(i-3)%3]&lt;/code&gt;决定&lt;/p&gt;

&lt;p&gt;Maximal Square
&lt;a href=&quot;https://www.lintcode.com/problem/maximal-square/description&quot;&gt;website&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j]&lt;/code&gt; 表示以&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;为正方形右下角可以扩展的最大边长&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if matrix[i][j] == 1
  f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1;
if matrix[i][j] == 0
  f[i][j] = 0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f[i][0] = matrix[i][0]
f[0][j] = matrix[0][j]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;max{f[i][j]}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[2][n]&lt;/code&gt;的矩阵即可&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if matrix[i][j] == 1
	f[i%2][j] = min(f[(i-1)%2][j], f[i%2][j-1], f[(i-1)%2][j-1]) + 1;
if matrix[i][j] = 0
	f[i%2][j] = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;局部最优和全局最优&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;maximum subarray 
&lt;a href=&quot;https://www.lintcode.com/problem/maximum-subarray/description&quot;&gt;website&lt;/a&gt;
use presum array&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (j = 0-&amp;gt;n)
	for (i = 0-&amp;gt;j)
		presum[j+1] - presum[i](add dummy 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;local[i]&lt;/code&gt;表示包括第i个元素能够找到的最大值(一定要取第i个元素能够取得的最大值)
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[i]&lt;/code&gt;表示全局前i个元素中能够找到的最大值&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;local[i] = Max(nums[i], local[i-1]+nums[i]);&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[i] = Max(local[i], global[i-1]);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;loacl[0] = global[0] = nums[0]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;global[n-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;maximum product subarray
&lt;a href=&quot;https://www.lintcode.com/problem/maximum-product-subarray/description&quot;&gt;website&lt;/a&gt;
use preproduct array
最初加一个1&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (j = 0-&amp;gt;n)
	for (i = 0-&amp;gt;j)
		preproduct[j+1] / preproduct[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;need to record max, min&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;min[i]&lt;/code&gt; 表示前i个数包括第i个数找到的最小乘积
&lt;code class=&quot;highlighter-rouge&quot;&gt;max[i]&lt;/code&gt;表示前i个数包括第i个数找到的最大乘积&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;min[i] = Min(nums[i], Min(min[i-1] * nums[i], max[i-1] * nums[i]));
max[i] = Max(nums[i], Max(max[i-1] * nums[i], min[i-1] * nums[i]));
global[i] = Max(global[i-1], max[i]);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;min[0] = max[0] = nums[0];&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;gloabl[n-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Best time to buy and sell stocks IV 
&lt;a href=&quot;https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iv/description&quot;&gt;website&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j]&lt;/code&gt;表示前i天进行j次交易能够获得的最大收益&lt;/li&gt;
  &lt;li&gt;方程
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][j] = max{f[x][j-1] + profit(x+1, i)} {x=0-&amp;gt;i-1}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;初始化
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[i][0] = 0, f[0][i] = -INT_MAX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;答案
&lt;code class=&quot;highlighter-rouge&quot;&gt;f[n-1][k]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A second method:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;状态
&lt;code class=&quot;highlighter-rouge&quot;&gt;mustSell[i][j]&lt;/code&gt;表示前i天，最多进行j次交易，前i天必须sell的最大获益
&lt;code class=&quot;highlighter-rouge&quot;&gt;globalbest[i][j]&lt;/code&gt;表示前i天，最多进行j次交易，第i天可以不sell的最大获益&lt;/li&gt;
  &lt;li&gt;方程
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gain = prices[i] - prices[i-1]
mustsell[i][j] = Max(globalbest[i-1][j-1] + gain, mustsell[i-1][j]+gain)
globalbest[i][j] = Max(globalbest[i-1][j], mustsell[i][j])
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mustsell[0][i] = globalbest[0][j] = 0;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;答案
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;globalbest[n-1][k]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;记忆化搜索&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;longest increasing continuous&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Algorithm" /><summary type="html">Dynamic Programming 空间优化 局部优化和全局最优实现时间优化 记忆化搜索</summary></entry><entry><title type="html">LLVM Intro</title><link href="http://localhost:4000/blog/2018/05/31/llvm/" rel="alternate" type="text/html" title="LLVM Intro" /><published>2018-05-31T00:00:00-07:00</published><updated>2018-05-31T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/31/llvm</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/31/llvm/">&lt;p&gt;I've been reading LLVM material for a whole day. It's a really exicting work by Chris Lattner(He build the project during his graduate study, how amazing!)&lt;/p&gt;
&lt;h3 id=&quot;heading-1-intro&quot;&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;LLVM is a &lt;strong&gt;compiler&lt;/strong&gt;. Different from other compilers, LLVM can achieve cross-platform compilation. LLVM has intermediate representation(IR) which is a great innovation and make the project independent from platform. Since it has backend to translate IR to target machine without human interference. This &lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/llvm.html&quot;&gt;page&lt;/a&gt; provides an introductory material for LLVM users. 
&lt;img src=&quot;/assets/images/compiler_arch.PNG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In compiler classes, we know compiler can be divided into front end and back end. The front end for compiler is &lt;strong&gt;Clang&lt;/strong&gt;, and back-end is simply LLVM it self which helps to translate IR into different assembly languages on various machine. Here our focus is on &lt;strong&gt;pass&lt;/strong&gt;. Passes translate IR to IR and help to optimize code generation. 
These intermediate representtaion is more &lt;strong&gt;regular&lt;/strong&gt; structurally. It's easier for us to analyze these assembly language compared to x86.&lt;/p&gt;

&lt;p&gt;To install LLVM, simply follow these 12 steps:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. svn co https://user@llvm.org/svn/llvm-project/llvm/tags/RELEASE_500/final llvm
2. cd llvm/tools
3. svn co http://llvm.org/svn/llvm-project/cfe/tags/RELEASE_500/final clang
4. cd clang/tools # (To be clear, you are now in llvm/tools/clang/tools)
5. svn co http://llvm.org/svn/llvm-project/clang-tools-extra/tags/RELEASE_500/final extra
6. cd ../../../../llvm/projects # (To be clear, you are now in llvm/projects)
7. svn co http://llvm.org/svn/llvm-project/compiler-rt/tags/RELEASE_500/final compiler-rt
8. cd ../../.. (You are now in your desktop directory)
9. mkdir build (if you have not already done so)
10. cd build (You are now in your build directory)
11. cmake -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; -DLLVM_TARGET_ARCH=X86
-DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLVM_BUILD_EXAMPLES=1
-DCLANG_BUILD_EXAMPLES=1 -G &quot;Unix Makefiles&quot; ../source/llvm/
12. 'make -j 8' (from within the build directory to start the process)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The material is copied from a &lt;a href=&quot;https://www.youtube.com/watch?v=VKIv_Bkp4pk&quot;&gt;talk&lt;/a&gt; given by Mike Shah.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-try-function-pass&quot;&gt;2. Try Function Pass&lt;/h3&gt;
&lt;p&gt;I simply follow the steps descirbed by &lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/llvm.html&quot;&gt;page&lt;/a&gt;. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git clone https://github.com/sampsyo/llvm-pass-skeleton.git&lt;/code&gt;
and&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd llvm-pass-skeleton
$ mkdir build
$ cd build
$ cmake ..  # Generate the Makefile.
$ make  # Actually build the pass.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so test.cpp&lt;/code&gt;
This code cannot work on my machine. And I add one flag:
&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -lstdc++ test.cpp&lt;/code&gt;
It works!&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;Module&lt;/strong&gt; represents a source file (roughly) or a translation unit (pedantically). Everything else is contained in a Module.&lt;/p&gt;

&lt;p&gt;Most notably, Modules house &lt;strong&gt;Functions&lt;/strong&gt;, which are exactly what they sound like: named chunks of executable code. (In C++, both functions and methods correspond to LLVM Functions.)&lt;/p&gt;

&lt;p&gt;Aside from declaring its name and arguments, a Function is mainly a container of &lt;strong&gt;BasicBlocks&lt;/strong&gt;. The basic block is a familiar concept from compilers, but for our purposes, it’s just a contiguous chunk of instructions.&lt;/p&gt;

&lt;p&gt;An &lt;strong&gt;Instruction&lt;/strong&gt;, in turn, is a single code operation. The level of abstraction is roughly the same as in RISC-like machine code: an instruction might be an integer addition, a floating-point divide, or a store to memory, for example.
&lt;strong&gt;Module, Functions, Block and Instruction&lt;/strong&gt; are C++ classes inherit from a base class &lt;strong&gt;Value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If you want to see LLVM IR, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;clang -emit -llvm -S -o -test.c&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;namespace {
	struct SkeletonPass : public FunctionPass {
		static char ID;
		SkeletonPass() : FunctionPass(ID) {}

		virtual bool runOnFunction(Functon &amp;amp;F) {
			errs() &amp;lt;&amp;lt; &quot;In a function called &quot; &amp;lt;&amp;lt; F.getName() &amp;lt;&amp;lt; &quot;!\n&quot;;
			errs() &amp;lt;&amp;lt; &quot;Function body:\n&quot;;
			F.print(llvmLerrs());
			for (auto &amp;amp;B : F) {
				errs() &amp;lt;&amp;lt; &quot;Basic block:\n&quot;;
				B.print(llvm::errs(), true);

				for (auto &amp;amp;I : B) {
					errs() &amp;lt;&amp;lt; &quot;Instruction: &quot;;
					I.print(llvm::errs(), true);
				}
			}
			return false;
		}
	};
}
char SkeletonPass::ID = 0;
static void registerSkeletonPass(const PassManagerBuilder&amp;amp;, legacy::PassManagerBase &amp;amp;PM) {
	PM.add(new SkeletonPass());
}
static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;heading-3-link-with-a-run-time-library&quot;&gt;3. Link with a Run-time library&lt;/h3&gt;
&lt;p&gt;You can write your run-time behavior in C and link it with the program you've compiled. And LLVM can help you link them together.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Get the function to call from our runtime library.
LLVMContext&amp;amp; Ctx = F.getContext();
Constant* logFunc = F.getParent()-&amp;gt;getOrInsertFunction(
  &quot;logop&quot;, Type::getVoidTy(Ctx), Type::getInt32Ty(Ctx), NULL
);

for (auto&amp;amp; B : F) {
  for (auto&amp;amp; I : B) {
    if (auto* op = dyn_cast&amp;lt;BinaryOperator&amp;gt;(&amp;amp;I)) {
      // Insert *after* `op`.
      IRBuilder&amp;lt;&amp;gt; builder(op);
      builder.SetInsertPoint(&amp;amp;B, ++builder.GetInsertPoint());

      // Insert a call to our function.
      Value* args[] = {op};
      builder.CreateCall(logFunc, args);

      return true;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The tool you need are &lt;code class=&quot;highlighter-rouge&quot;&gt;Module::getOrInsertFunction&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;IRBuilder::CreateCall&lt;/code&gt;. The former adds a declaration for your runtime function &lt;code class=&quot;highlighter-rouge&quot;&gt;logop&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void logop(int i) {
  printf(&quot;computed: %i\n&quot;, i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cc -c rtlib.c
$ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c example.c
$ cc example.o rtlib.o
$ ./a.out
12
computed: 14
14
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">I've been reading LLVM material for a whole day. It's a really exicting work by Chris Lattner(He build the project during his graduate study, how amazing!) 1. Intro LLVM is a compiler. Different from other compilers, LLVM can achieve cross-platform compilation. LLVM has intermediate representation(IR) which is a great innovation and make the project independent from platform. Since it has backend to translate IR to target machine without human interference. This page provides an introductory material for LLVM users.</summary></entry><entry><title type="html">Vim Script</title><link href="http://localhost:4000/blog/2018/05/26/Vim_script/" rel="alternate" type="text/html" title="Vim Script" /><published>2018-05-26T00:00:00-07:00</published><updated>2018-05-26T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/26/Vim_script</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/26/Vim_script/">&lt;p&gt;Vim has its own scripting language, most standard dynamic-language features&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:vmap &amp;lt;expr&amp;gt; aa Select_Entire_File()
:nmap x :call Comment_To_EOF()
:imap &amp;lt;expr&amp;gt; \p Insert_Balanced_Tags('&amp;lt;p&amp;gt;')
:nmap	;y :call Taggle_Syntax()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Variables, expression, control structures, build-in functions … 
For full details:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:help vim-scrpt-intro
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For endless examples:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://vim.sourceforge.net/scripts/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For detailed work examples:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.ibm.com/developerworks/library/l-vim-script-1/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Five ways to execute vim scripts
(1) simplest: put them in &lt;code class=&quot;highlighter-rouge&quot;&gt;.vim&lt;/code&gt; file
and then execute it with &lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source ./scriptfile.vim&lt;/code&gt;
(2) &lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt; the file you are editing
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source %&lt;/code&gt;
(3) If file somewhere in &lt;code class=&quot;highlighter-rouge&quot;&gt;$VIMRUNTIME&lt;/code&gt; path
&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime scriptfile.vim&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:source&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;:runtime&lt;/code&gt; are handy ways of factoring out parts of your &lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;
More useful in a live session:
Can type commands directly on command-line:
&lt;code class=&quot;highlighter-rouge&quot;&gt;:call MyBackupFunc(expand('%'), {'all':1, 'save':'recent'})&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:command SF source scriptfile.vim
:command -nargs=1 MBF call MyBackupFunc(expand(&amp;lt;q-args&amp;gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Even more useful is triggering a command from Normal mode…
Create &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; to type it for you:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap ;s :source scriptfile.vim&amp;lt;CR&amp;gt;
:nmap \b :call MyBackupFunc(expand('%'), {'all' : 1})&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For the very least effort&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:autocmd BufReadPost *.txt source scriptfile.vim
:autocmd WinLeave * call MyBackupFunc(expand('%'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;heading-statement&quot;&gt;Statement&lt;/h3&gt;
&lt;p&gt;all statements terminated by newline:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &quot;Starting&quot;
call Phase(1)
echo &quot;Done&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To continue across multiple lines, start next line with backslash:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let full_name = 
\ first_name . ' ' . middle_initial . ' ' . family_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To put two statements on one line, separate with vertical bar:
&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;Starting&quot; | call Phase(1) | call Phase(2) | echo &quot;Done&quot;&lt;/code&gt;
 Leading colon is also allowed in a Vim script, but not required:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function! Tidy_and_save()
	set expandtabs
	%retab!
	write
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-values&quot;&gt;Values&lt;/h3&gt;
&lt;p&gt;Four build-in types: &lt;code class=&quot;highlighter-rouge&quot;&gt;String, Number, List, and Dictionary&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1527350515440.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-commands&quot;&gt;commands&lt;/h3&gt;
&lt;p&gt;Start with double quote&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;
It run to end-of-line:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; This is a comment
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;So maybe add a more familiar marker&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call Setup(0) &quot; // comment
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-variables&quot;&gt;Variables&lt;/h3&gt;
&lt;p&gt;All assignments require &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; keyword
Vars can store numbers, strings, lists, dictionaries, or just function refs:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = &quot;Damian&quot;
let height = 170
let haha = {&quot;Vim&quot;, &quot;asdjl&quot;, &quot;key&quot;}
let duration = {&quot;vim&quot;:32, &quot;pasd&quot;:32}
let task = function('teach')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The variable type initialized with determinte the type of variable for the remaining time. 
if you &lt;code class=&quot;highlighter-rouge&quot;&gt;let duration = 90&lt;/code&gt; will cause a type error. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;unlet duration&lt;/code&gt;
&lt;img src=&quot;/assets/images/1527353138645.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;each scope name also a symbol table&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g:varname
g:['varname']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for varname in keys(b:)
	unlet b:[varname]
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1527353463462.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Give direct access to vim environment&lt;/p&gt;

&lt;h3 id=&quot;heading-expressions&quot;&gt;Expressions&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1527353726859.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; is string concatenation
All comparators do both string and numeric comparison
string comparisons honour &lt;code class=&quot;highlighter-rouge&quot;&gt;ignorecase&lt;/code&gt;
but can be explicitly marked case-sensitive(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)
case-insensitive(&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if name ==? 'Batman'
	echo &quot;I'm a Batman&quot;
else if name ==# 'ee cummings'
	echo &quot;asjdlj&quot;
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Most important limitation is on arithmetic
Numeric expressions are &lt;strong&gt;integer only&lt;/strong&gt;
Some floating point support in Vim 7.2
Common mistake:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for filenum in range(filecount)
	&quot;Show progress...
	echo(file / filecount * 100).'% done'
	&quot;Make progress...
	call progress_file(filenum)
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This will always echo &lt;code class=&quot;highlighter-rouge&quot;&gt;Now 0% done&lt;/code&gt;
have to use &lt;code class=&quot;highlighter-rouge&quot;&gt;filenum * 100 / filecount&lt;/code&gt;
Another notice point:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for result in result_list
	let sum += result
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-controlflow&quot;&gt;ControlFlow&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if condition
	statements()
elseif other_condition
	other_statements
else
	still()
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while condition
	statements()
endwhile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for varname in list
	statements()
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Parallel iteration&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for [var1, var2, etc] in listoflists
	statements()
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let g:words = {1:&quot;one&quot;, 2:&quot;two&quot;, 3:&quot;many&quot;, 4:&quot;lots&quot;}
for [key, val] in items(g:words)
	echo key. &quot;: &quot;.val
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for number in list_of_numbers
	if number &amp;lt; 0
		continue &quot;go to next loop
	elseif number &amp;gt; 9
		break &quot;Exit loop completely
	endif 
	echo number
endfor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Vim" /><summary type="html">Vim has its own scripting language, most standard dynamic-language features :vmap &amp;lt;expr&amp;gt; aa Select_Entire_File() :nmap x :call Comment_To_EOF() :imap &amp;lt;expr&amp;gt; \p Insert_Balanced_Tags('&amp;lt;p&amp;gt;') :nmap ;y :call Taggle_Syntax()</summary></entry><entry><title type="html">Vim abbreviation and map</title><link href="http://localhost:4000/blog/2018/05/25/Vim-abbreviation-and-map/" rel="alternate" type="text/html" title="Vim abbreviation and map" /><published>2018-05-25T00:00:00-07:00</published><updated>2018-05-25T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/25/Vim%20abbreviation%20and%20map</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/25/Vim-abbreviation-and-map/">&lt;h2 id=&quot;heading-vim-abbreviation-and-map&quot;&gt;Vim abbreviation and map&lt;/h2&gt;
&lt;p&gt;abbreviation&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:abbreviate hdco aperjump.com
:abbreviate ww wei@aperjump.me
:ab ww wei@aperjump.me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;There are strict limitations on what you can use a an abbreviation&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;must be an identifier consisting entirely of keyword characters:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab url http://www.baidu.com
ab krd Kind regards, &amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;Damian Conway
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;must consist entirely of non-keyword characters, except for the last one
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab #1 I'll make that my number one priority
ab --c &amp;lt;CR&amp;gt;----cut------cut-----cut-&amp;lt;C-O&amp;gt;:center&amp;lt;CR&amp;gt;&amp;lt;DOWN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;must end in a &lt;strong&gt;non-keyword&lt;/strong&gt; character
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab ph# +1-802-555-1122
ab ??? //
ab orz! I'm not worthy
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;expand abbreviation
Abbreviations also require some trailing context to know they've been entered
–&amp;gt; you need to type a non-keyword character after the abbreviation before it will be expanded
You can expand an abbreviation without trailing context by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL-]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;How to review abbreviation
If you type&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:abbreviate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;without an argumant, you can get a list of the active abbreviations
To remove abs, just type &lt;code class=&quot;highlighter-rouge&quot;&gt;:unabbreviate bqc&lt;/code&gt; or clear all &lt;code class=&quot;highlighter-rouge&quot;&gt;:abclear&lt;/code&gt;
To deactivate them type a literal &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;CRTL-V&amp;gt;&lt;/code&gt; before the abbreviation
For example, if you frequently need to save to a particular file:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:ab bak /usr/local/tmp/backup/damian/checkpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;A better option is &lt;code class=&quot;highlighter-rouge&quot;&gt;iabbrev&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cabbrev&lt;/code&gt; versions
With these you can tell Vim exactly where to expand the abbreviation:
Only in insertions:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:iabbrev bqc &amp;lt;blockquote&amp;gt;&amp;lt;cite&amp;gt;&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&amp;lt;/cite&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;lt;UP&amp;gt;&amp;lt;TAB&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;only in command line:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:cabbrev bak /usr/local/tmp/backup/damian/checkpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;You can specify an abbreviation should expand to the result of some expression in the vimmish command language&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:iabbr &amp;lt;expr&amp;gt; TS strftime(&quot;%c&quot;)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:iabbr &amp;lt;expr&amp;gt; PPP getreg('')&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-1-maps&quot;&gt;1. Maps&lt;/h3&gt;
&lt;p&gt;Abbreviations are grreat, but suffer from two major constraints
They're only available in Insert mode and on the command line
They require an extra character typed after them&lt;/p&gt;

&lt;p&gt;Mays remedy both those problems
A map creates a sequence that is expanded as soon as typed
A &lt;strong&gt;macro&lt;/strong&gt;
We can specify maps for specific modes&lt;/p&gt;

&lt;h4 id=&quot;heading-11-insert-map&quot;&gt;1.1 Insert map&lt;/h4&gt;
&lt;p&gt;They can be used to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;iabbr&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:imap ww http://www.google.com
:imap ee wei@aperjump.me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;advantage: don't require additional character to be typed&lt;/p&gt;

&lt;h4 id=&quot;heading-12-normal-map&quot;&gt;1.2 Normal map&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap X dip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;dip: delete the interior of paragraph
Likewise, if visual block mode more useful than visual line mode.
We can use this&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap v &amp;lt;C-V&amp;gt;
:nmap &amp;lt;Space&amp;gt; &amp;lt;PageDown&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Or we can streamline file navigation:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:nmap &amp;lt;DOWN&amp;gt; :next&amp;lt;CR&amp;gt;
:nmap &amp;lt;UP&amp;gt; prev&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;heading-13-command-line-maps&quot;&gt;1.3 Command line maps&lt;/h4&gt;
&lt;p&gt;If you frequently write to a backup file:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:w ~/backup/latest&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can add this to &lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmap wb w ~/backup/latest&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;or we can simplify subdirectory tours:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:cmap *** **/*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;which then allows:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:next examples/***.c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Vim" /><summary type="html">Vim abbreviation and map abbreviation :abbreviate hdco aperjump.com :abbreviate ww wei@aperjump.me :ab ww wei@aperjump.me There are strict limitations on what you can use a an abbreviation must be an identifier consisting entirely of keyword characters: ab url http://www.baidu.com ab krd Kind regards, &amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;Damian Conway must consist entirely of non-keyword characters, except for the last one ab #1 I'll make that my number one priority ab --c &amp;lt;CR&amp;gt;----cut------cut-----cut-&amp;lt;C-O&amp;gt;:center&amp;lt;CR&amp;gt;&amp;lt;DOWN&amp;gt; must end in a non-keyword character ab ph# +1-802-555-1122 ab ??? // ab orz! I'm not worthy</summary></entry><entry><title type="html">Syntax Analysis</title><link href="http://localhost:4000/blog/2018/05/19/syntax_analysis/" rel="alternate" type="text/html" title="Syntax Analysis" /><published>2018-05-19T00:00:00-07:00</published><updated>2018-05-19T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/19/syntax_analysis</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/19/syntax_analysis/">&lt;h3 id=&quot;heading-1-intro&quot;&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;main topic: parsing methods
&lt;img src=&quot;/assets/images/1526745213800.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The parser constructs a parse tree and passes it to the rest of the compiler for further processing.&lt;/p&gt;

&lt;p&gt;Two parser methods: &lt;strong&gt;top-down&lt;/strong&gt;(from root to leaves) and &lt;strong&gt;bottom-up&lt;/strong&gt;(from leaves to root). The input for parser is scanned from left to right, one symbol at a time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LL&lt;/strong&gt; and &lt;strong&gt;LR&lt;/strong&gt; are expressive tools to describe most of the syntactic constructs in modern programming language. Parser implemented by hand often use &lt;strong&gt;LL&lt;/strong&gt; grammars. Parser for larger class of &lt;strong&gt;LR&lt;/strong&gt; grammars are usually constructed using automated tools.&lt;/p&gt;

&lt;p&gt;In practice, there are a number of tasks that might be conducted during parsing, such as collecting information about various tokens into the symbol table, performing type checking and other kind of semantic analysis and generating intermediate code.&lt;/p&gt;

&lt;h4 id=&quot;heading-11-representative-grammars&quot;&gt;1.1 Representative Grammars&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1526745812598.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This expression belongs to the class of &lt;strong&gt;LR&lt;/strong&gt; grammars that are suitable for &lt;strong&gt;bottom-up&lt;/strong&gt; parsing. This grammar can be adapted to handle additional operators and additional levels of precedence. However, it cannot be used for &lt;strong&gt;top-down&lt;/strong&gt; parsing because it is left-recursive.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;left-recursive —&amp;gt; bottom up
non-left-recursive —&amp;gt; top down&lt;/p&gt;
  &lt;h4 id=&quot;heading-12-error-handling&quot;&gt;1.2 Error handling&lt;/h4&gt;
  &lt;p&gt;Two strategies: &lt;strong&gt;panic mode&lt;/strong&gt; and &lt;strong&gt;phrase-level recovery&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(1) panic mode&lt;/p&gt;

&lt;p&gt;On discovering an error, the parser discards input symbols one at a time until one of a designed set of &lt;strong&gt;synchronizing token&lt;/strong&gt; is found. The synchronizing tokens are usually delimiters, such as semicolon or &lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(2) phrase level recovery&lt;/p&gt;

&lt;p&gt;On discovering an error, a parser may perform local correction on the remaining input; that is, it may replace a prefix of the remaining input by some string that allows the parser to continue.&lt;/p&gt;

&lt;p&gt;A typical local correction is to replace a comma by a semicolon, delete an extraneous semicolon, or insert a missing semicolon.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-context-free-grammar&quot;&gt;2. Context-free Grammar&lt;/h3&gt;

&lt;p&gt;definition: A context-free grammar consists of terminals, nonterminals, a start symbol, and productions.&lt;/p&gt;

&lt;p&gt;(1) terminals are the basic symbols from which strings are formed. &lt;strong&gt;We assume terminals are the first components of the tokens output by the lexical analyzer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;(2) nonterminals are syntactic variables that denote sets of strings. The sets of strings denoted by nonterminals help define the language generated by the grammar. Nonterminals impose a hierarchical structure on the language that is key to syntax analysis and translation.&lt;/p&gt;

&lt;p&gt;(3) start symbol is the set of strings it denotes is the language generated by the grammar.&lt;/p&gt;

&lt;p&gt;(4) production specify the manner in which terminals and nonterminals can be combined to form strings.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stmt -&amp;gt; if (expr) stmt else stmt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If $\S \xrightarrow{*} \alpha$, where $S$ is the start symbol of a grammar $G$, we say that $\alpha$ is the &lt;strong&gt;sentential form&lt;/strong&gt; of $G$. A sentential form may contain both terminals and nontermnials or even empty string. A &lt;strong&gt;sentence&lt;/strong&gt; of $G$ is a sentential form with no nonterminals. The language generated by a grammar is its set of sentences.&lt;/p&gt;

&lt;p&gt;Thus a string of terminals $\omega$ is in $L(G)$, the language generated by $G$. iff $\omega$ is a sentence of $G$, or $S \xrightarrow{*} \omega$. A language that can be generated by a grammar is said to be &lt;strong&gt;context-free&lt;/strong&gt; grammar.&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;leftmost&lt;/strong&gt; derivations, the leftmost nonterminal in each sentential is always chosen. 
$\alpha \xrightarrow{lm} \beta$&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;rightmost&lt;/strong&gt; derivations, the rightmost nonterminal is always chosen. 
$\alpha \xrightarrow{rm} \beta$&lt;/p&gt;
&lt;h4 id=&quot;heading-21-parse-tree&quot;&gt;2.1 Parse Tree&lt;/h4&gt;
&lt;p&gt;A parse tree is a graphical representation of a derivation that filters out the order in which productions are applied to replace nonterminals. 
&lt;img src=&quot;/assets/images/1526748378855.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The leaves of a parse tree are labeled by nonterminals or terminals and read from left to right constitute a sentential form, called the &lt;strong&gt;yield&lt;/strong&gt; or &lt;strong&gt;frontier&lt;/strong&gt; of the tree.&lt;/p&gt;

&lt;p&gt;A parse tree ignores variations in the order in which symbols in sentential forms are replaced, there is a many-to-one relationship between derivations and parse tree. **we shall frequently parse by producing a leftmost or a rightmost derivation, since there is a one-to-one relationship between parse trees and either leftmost or rightmost derivations.&lt;/p&gt;

&lt;h4 id=&quot;heading-22-context-free-grammar-and-regular-expression&quot;&gt;2.2 context-free grammar and regular expression&lt;/h4&gt;

&lt;p&gt;every constructs that can be described by a regular expression can be described  by a grammar, but not vice-versa. Every regular expression is a context-free grammar, but not vice-versa.&lt;/p&gt;

&lt;h3 id=&quot;heading-3-writing-a-grammar&quot;&gt;3. Writing a Grammar&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1526750747974.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if E1 then if E2 then S1 else S2&lt;/code&gt;  has two parse trees. 
&lt;img src=&quot;/assets/images/1526750795078.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How to rewrite the grammar?&lt;/p&gt;

&lt;p&gt;idea: the statement between &lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; must be matched. 
&lt;img src=&quot;/assets/images/1526762609720.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;heading-31-eliminate-left-recursion&quot;&gt;3.1 eliminate left recursion&lt;/h4&gt;
&lt;p&gt;A grammar is &lt;strong&gt;left recursive&lt;/strong&gt; if it has a nonterminal $A$ such that there is a derivation $A \xrightarrow{+} A\alpha$. Here is one rule $A \xrightarrow{}A\alpha | \beta$ can be replaced by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \beta A' \\
	 A' \rightarrow \alpha A' | \epsilon&lt;/script&gt;

&lt;p&gt;Here we can change the rule in first section to this one (using the rule above)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id&lt;/script&gt;

&lt;p&gt;One general rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow A\alpha_1 | A\alpha_2 | ...|A\alpha_m | \beta_1 | \beta_2 | ... | \beta_m&lt;/script&gt;

&lt;p&gt;can be replaced by&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \beta_1A' | \beta_2A' | ... | \beta_n A' \\
	 A' \rightarrow \alpha_1A' | \alpha_2A' | ... | \alpha_m A' | \epsilon&lt;/script&gt;

&lt;h4 id=&quot;heading-32-left-factoring&quot;&gt;3.2 Left Factoring&lt;/h4&gt;
&lt;p&gt;Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive, top-down, parsing. When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen that we can make the right choice.&lt;/p&gt;

&lt;p&gt;For example: original rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \alpha \beta_1 | \alpha\beta_2&lt;/script&gt;

&lt;p&gt;can be left factor into&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow \alpha A' \\
	 A \rightarrow \beta_1 | \beta_2&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526764155565.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-4-top-down-parsing&quot;&gt;4. Top-down parsing&lt;/h3&gt;
&lt;p&gt;Top-down parsing can be viewed as finding a &lt;strong&gt;leftmost&lt;/strong&gt; derivation for an input string.&lt;/p&gt;

&lt;p&gt;main problem is find production for nonterminal A.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;recursive descent parsing&lt;/strong&gt;(requre backtracking).&lt;/p&gt;

&lt;p&gt;predictive parsing is a special case of recursive parsing, where no backtracing is required. Predictive parsing choose the correct A-production by looking ahead at the input a fixed number of symbols.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526764567285.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The class of grammars for which we can construct predictive parsers looking k symbols ahead in the input is called &lt;strong&gt;LL(k)&lt;/strong&gt; class.&lt;/p&gt;
&lt;h4 id=&quot;heading-41-recursive-descent-parsing&quot;&gt;4.1 Recursive-Descent Parsing&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void A() {
	Choose an A-production, A -&amp;gt; X1X2...Xk;
	for (i = 1 to k) {
		if (Xi is a nonterminal)
			call procedure Xi();
		else if (Xi equals the current input symbol a)
			advance the input to the next symbol;
		else
			catch error
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To allow backtracking, the code needs to be modified. First, we cannot choose a unique A-production in line (1), so we must try several productions. The failure in last &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; should return back to the first choice procedure. Only if there is no more A-production to try, there is a true error.&lt;/p&gt;

&lt;h4 id=&quot;heading-42-first-and-follow&quot;&gt;4.2 FIRST and FOLLOW&lt;/h4&gt;
&lt;p&gt;$FIRST$ and $FOLLOW$ allow us to choose which production to apply, based on the next input symbol.&lt;/p&gt;

&lt;p&gt;Consider non-terminal A, production $A\rightarrow\alpha$, and we have input symbol $t$&lt;/p&gt;

&lt;p&gt;$T[A,t] = \alpha$ in two cases($T$ is transition table):&lt;/p&gt;

&lt;p&gt;(1) if $\alpha \xrightarrow{*} t\beta$&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$\alpha$ can derive a $t$ in the first position&lt;/li&gt;
  &lt;li&gt;we say that $t\in FIRST(\alpha)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) if $A\rightarrow\alpha$ and $\alpha \xrightarrow{&lt;em&gt;} \epsilon$ and $S \xrightarrow{&lt;/em&gt;}\beta At\delta$&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;useful if stack has $A$, input is $t$, and $A$ cannot derive $t$&lt;/li&gt;
  &lt;li&gt;In this case only option is to get rid of $A$ by deriving $\epsilon$&lt;/li&gt;
  &lt;li&gt;we say that $t\in FOLLOW(A)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$FIRST(\alpha)$, where $\alpha$ is any string of grammar symbols, to be the set of terminals that begin strings derived from $\alpha$. For example $A\xrightarrow{&lt;em&gt;}c\gamma$, so $c$ is in $FIRST(A)$. $FIRST(X)={t|X \xrightarrow{&lt;/em&gt;}t\alpha} \cup {\epsilon | X \xrightarrow{*} \epsilon}$
Algo:&lt;/p&gt;

&lt;p&gt;(1) if $FIRST(t) = {t}$(t is terminal)&lt;/p&gt;

&lt;p&gt;(2) $\epsilon \in FIRST(X)$ if $X\rightarrow\epsilon$ or if $X\rightarrow A_1…A_n$ and $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$&lt;/p&gt;

&lt;p&gt;(3) $FIRST(\alpha) \subseteq FIRST(X)$ if $X\rightarrow A_1…A_n\alpha$ and  $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$&lt;/p&gt;

&lt;p&gt;$FOLLOW(A)$ for nonterminal $A$ is the set of terminals $a$ that can appear immediately to the right of $A$ in some &lt;strong&gt;sentential form&lt;/strong&gt;; that is, the set of terminals $a$ such that there exists a derivation of the form 
$S\xrightarrow{&lt;em&gt;}\alpha A\alpha\beta$
In addition, if $A$ can be the rightmost symbol in some sentential form, then $$$ is in $FOLLOW(A)$; $$$ reprents &quot;endmark&quot;. $FOLLOW(X) = {t|S\xrightarrow{&lt;/em&gt;} \beta Xt\delta}$&lt;/p&gt;

&lt;p&gt;Intuition:&lt;/p&gt;

&lt;p&gt;If $X\rightarrow AB$ then $FIRST(B) \subseteq FOLLOW(A)$ and $FOLLOW(X) \subseteq FOLLOW(B)$&lt;/p&gt;

&lt;p&gt;If $B\xrightarrow{*}\epsilon$ then $FOLLOW(X) \subseteq FOLLOW(A)$
If $S$ is the start symbol then $$ \in FOLLOW(S)$&lt;/p&gt;

&lt;p&gt;Algo:&lt;/p&gt;

&lt;p&gt;(1) $$\in FOLLOW(S)$&lt;/p&gt;

&lt;p&gt;(2) $FIRST(\beta) - {\epsilon} \subseteq FOLLOW(X)$ for each production $A \rightarrow \alpha X\beta$($FOLLOW$ sets are just terminals, no empty set)&lt;/p&gt;

&lt;p&gt;(3) $FOLLOW(A) \subseteq FOLLOW(X)$ for each production  $A \rightarrow \alpha X\beta$ where $\epsilon \in FIRST(\beta)$&lt;/p&gt;

&lt;h4 id=&quot;heading-43-ll1&quot;&gt;4.3 LL(1)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;no left-recursive or ambiguous grammar in LL(1)&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A grammar $G$ is LL(1) iff whenever $A\rightarrow\alpha&lt;/td&gt;
      &lt;td&gt;\beta$ are two distinct productions of $G$.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1526769704732.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our goal here is to construct a parsing table $T$ for context-free grammar $G$&lt;/p&gt;

&lt;p&gt;For each production $A\rightarrow \alpha$ in $G$ do:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For each terminal $t \in FIRST(\alpha)$ do 
      $T[A,t] = \alpha$&lt;/li&gt;
  &lt;li&gt;If $\epsilon \in FIRST(\alpha)$ for each $t \in FOLLOW(A)$ do
      $T[A,t] = \alpha$&lt;/li&gt;
  &lt;li&gt;If $\epsilon \in FIRST(\alpha)$ and $$ \in FOLLOW(A)$ do
      $T[A,$] = \alpha$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**If any entry is multiply defined then $G$ is not LL(1). **&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;not left factored&lt;/li&gt;
  &lt;li&gt;left recursive&lt;/li&gt;
  &lt;li&gt;ambiguous
…&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">1. Intro main topic: parsing methods</summary></entry><entry><title type="html">Constructing Compiler: flex intro</title><link href="http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro/" rel="alternate" type="text/html" title="Constructing Compiler: flex intro " /><published>2018-05-18T00:00:00-07:00</published><updated>2018-05-18T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/18/compiler_construct_flex_intro/">&lt;h3 id=&quot;heading-flex-intro&quot;&gt;Flex intro&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;flex&lt;/strong&gt; is a tool for generating &lt;strong&gt;scanners&lt;/strong&gt;. This article is my notes for using &lt;strong&gt;flex&lt;/strong&gt;, and most of the material can be found in &lt;a href=&quot;http://westes.github.io/flex/manual/&quot;&gt;website&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* flex syntax */
definitions
%%
rules
%%
user code
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;When the scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, take the longest match token. 
One the match is determined, the text corresponding to the match(&lt;strong&gt;token&lt;/strong&gt;) is made available in the global character pointer &lt;strong&gt;yytext&lt;/strong&gt;, and its length in the global integer &lt;strong&gt;yyleng&lt;/strong&gt;. The &lt;strong&gt;action&lt;/strong&gt; corresponding to the matched pattern is then executed. 
If no match is found, then the default rule is: &lt;strong&gt;the next character in the input is considered matched and copied to the standard ouput.&lt;/strong&gt;
&lt;strong&gt;yytext&lt;/strong&gt; can be defined as a pointer or array
use &lt;code class=&quot;highlighter-rouge&quot;&gt;%pointer&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;%array&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-1-actions&quot;&gt;1. actions&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; %%
[ \t]+        putchar( ' ' );
[ \t]+$       /* ignore this token */
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The action consisting solely of a vertical bar &lt;code class=&quot;highlighter-rouge&quot;&gt;('|')&lt;/code&gt; means &quot;same as the action for the next rule&quot;. 
Actions can include arbitrary C code, including &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; statements to return a value to whatever routine called &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt;. Each time &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt; is called it continues processing tokens from where it last left off until it either reaches the end of the file or executes a return. 
More detailed &lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt; description can be found &lt;a href=&quot;http://westes.github.io/flex/manual/Actions.html#Actions&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-2-generated-scanner&quot;&gt;2. generated scanner&lt;/h3&gt;
&lt;p&gt;output file: &lt;code class=&quot;highlighter-rouge&quot;&gt;lex.yy.c&lt;/code&gt;(includes scanning routine &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt;, symbol table, and macros)
whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;yylex()&lt;/code&gt; is called, it scans tokens from the global input file &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt;(which defaults to &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;). It continues until it either reaches an end-of-file or one of its actions executes a &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; statement. 
If the scanner reaches an end-of-file, subsequent calls are undefined unless either &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt; is pointed at a new input file, or &lt;code class=&quot;highlighter-rouge&quot;&gt;yystart()&lt;/code&gt; is called. &lt;code class=&quot;highlighter-rouge&quot;&gt;yystart()&lt;/code&gt; takes one argument, a &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE *&lt;/code&gt; pointer, and initializes &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt; for scanning from that file. 
By default, the scanner uses block-reads rather than simple &lt;code class=&quot;highlighter-rouge&quot;&gt;getc()&lt;/code&gt; calls to read characters from &lt;code class=&quot;highlighter-rouge&quot;&gt;yyin&lt;/code&gt;. This is controlled by defining &lt;code class=&quot;highlighter-rouge&quot;&gt;YY_INPUT&lt;/code&gt; macro. &lt;code class=&quot;highlighter-rouge&quot;&gt;YY_INPUT(buf, result, max_size)&lt;/code&gt;its action is to place up to &lt;code class=&quot;highlighter-rouge&quot;&gt;max_size&lt;/code&gt; characters in the &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt; and return in the integer variable &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%{
 #define YY_INPUT(buf,result,max_size) \
     { \
     int c = getchar(); \
     result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
     }
 %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-3-start-conditions&quot;&gt;3. start conditions&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flex&lt;/code&gt; provides a mechanism for conditionally activating rules. Any rule whose pattern is prefixed with &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sc&amp;gt;&lt;/code&gt; will only be active when the scanner is in the start condition named &lt;code class=&quot;highlighter-rouge&quot;&gt;sc&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;STRING&amp;gt;[^&quot;]* {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;will be active only when the scanner is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING&lt;/code&gt; start condition. 
Start conditions are declared in the definitions section of the input using lines beginning with either &lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;(inclusive) or &lt;code class=&quot;highlighter-rouge&quot;&gt;%x&lt;/code&gt;(exclusive). 
A start condition is activated using the &lt;code class=&quot;highlighter-rouge&quot;&gt;BEGIN&lt;/code&gt; action.  If the start condition is inclusive, then rules with no start conditions at all will also be active. If it is exclusive, then only rules qualified with the start condition will be active.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%{
#include &amp;lt;math.h&amp;gt;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&amp;lt;expect&amp;gt;[0-9]+.[0-9]+      {
            printf( &quot;found a float, = %f\n&quot;,
                    atof( yytext ) );
            }
&amp;lt;expect&amp;gt;\n           {
            /* that's the end of the line, so
             * we need another &quot;expect-number&quot;
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {
            printf( &quot;found an integer, = %d\n&quot;,
                    atoi( yytext ) );
            }

&quot;.&quot;         printf( &quot;found a dot\n&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">Flex intro flex is a tool for generating scanners. This article is my notes for using flex, and most of the material can be found in website /* flex syntax */ definitions %% rules %% user code When the scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, take the longest match token. One the match is determined, the text corresponding to the match(token) is made available in the global character pointer yytext, and its length in the global integer yyleng. The action corresponding to the matched pattern is then executed. If no match is found, then the default rule is: the next character in the input is considered matched and copied to the standard ouput. yytext can be defined as a pointer or array use %pointer or %array</summary></entry><entry><title type="html">Lexical Analysis</title><link href="http://localhost:4000/blog/2018/05/10/Lexical-Analysis/" rel="alternate" type="text/html" title="Lexical Analysis " /><published>2018-05-10T00:00:00-07:00</published><updated>2018-05-10T00:00:00-07:00</updated><id>http://localhost:4000/blog/2018/05/10/Lexical%20Analysis</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/10/Lexical-Analysis/">&lt;h2 id=&quot;heading-lexical-analysis&quot;&gt;Lexical Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;goal&lt;/strong&gt;: identify each lexeme and return information on token&lt;/p&gt;
&lt;h3 id=&quot;heading-1-lexical-analyzer-role&quot;&gt;1 Lexical Analyzer Role&lt;/h3&gt;
&lt;p&gt;(1) read input characters, group them into lexemes, and produce output a sequence of tokens&lt;/p&gt;

&lt;p&gt;(2) When the lexical analyzer discovers a lexeme constituting an identifier, it needs to enter that lexeme into the symbol table.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525905998501.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The figure suggests, parser will call lexical analyzer, and lexical analyzer read characters until find next token. 
lexical analyzer will also do some additional jobs:&lt;/p&gt;

&lt;p&gt;(1) strip whitespace&lt;/p&gt;

&lt;p&gt;(2) record line number for error message&lt;/p&gt;
&lt;h4 id=&quot;heading-311-basic-concepts&quot;&gt;3.1.1 Basic Concepts&lt;/h4&gt;
&lt;p&gt;(1) A &lt;strong&gt;token&lt;/strong&gt; is a pair consisting of a token name and an optional attribute value. The token name is an abstract symbol representing a kind of lexical unit.&lt;/p&gt;

&lt;p&gt;(2) A &lt;strong&gt;pattern&lt;/strong&gt; is a description of the form that the lexemes of a token may take. 
the sequence of character which can form keywords&lt;/p&gt;

&lt;p&gt;(3) A &lt;strong&gt;lexeme&lt;/strong&gt; is a sequence of characters in the source program that matches the pattern for a token and is identified by the lexical analyzer as an instance of the token.&lt;/p&gt;

&lt;p&gt;In most programming languages, the following classes cover most or all of the tokens:&lt;/p&gt;

&lt;p&gt;(1) One token for each keyword. The pattern for a keyword is the same as the keyword itself.&lt;/p&gt;

&lt;p&gt;(2) Tokens for the operators&lt;/p&gt;

&lt;p&gt;(3) One token representing all identifiers.&lt;/p&gt;

&lt;p&gt;(4) One or more tokens representing constants&lt;/p&gt;

&lt;p&gt;(5) To kens for each punctuation symbol, such as left and right parentheses, comma, and semicolon.&lt;/p&gt;

&lt;p&gt;Sometimes, token can have different matches, for example, 0 and 1 both match for &lt;strong&gt;number&lt;/strong&gt;. So we not only need token names, we also need token attributes. The token name influences parsing decisions, while the attribute value influences translation of tokens after the parse. 
The appropriate attribute value for an identifier is a pointer to the symbol table entry for that identifier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lexical Errors&lt;/strong&gt; suppose a situation arises in which the lexical analyzer is unable to proceed because none of the patterns for tokens matches any prefix of the remaining input. The simplest recovery strategy is &quot;panic mode&quot; recovery. We delete successive characters from the remaining input, until the lexical analyzer can find a well-formed token at the beginning of what input is left. This recovery technique may confuse the parser, but in an interactive computing environment it may be quite adequate.&lt;/p&gt;

&lt;h3 id=&quot;heading-2-input-buffer&quot;&gt;2 Input Buffer&lt;/h3&gt;
&lt;p&gt;In Dragon book, we can see the example of Fortran language, which justifies the need to look ahead to help tokenize strings.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The goal is to partition the string. This is implemented by reading left-to-right, recognizing one token at a time.&lt;/li&gt;
  &lt;li&gt;&quot;Lookahead&quot; may be required to decide where one token ends and the next token begins. (we want to minimize look ahead)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many situations where we need to look at least one additional character ahead. 
&lt;img src=&quot;/assets/images/1525925908025.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can use a buffer pair to resolve the problem. Each buffer is of the same size N, which is usually the size of a disk block. Using one system read command we can read N characters into a buffer, rather than using one system call per character.&lt;/p&gt;

&lt;p&gt;In the buffer, two pointers are maintained.&lt;/p&gt;

&lt;p&gt;(1) Pointer lexemeBegin, marks the beginning of the current lexeme, whose extent we are attempting to determine.&lt;/p&gt;

&lt;p&gt;(2) Pointer forward scans ahead until a pattern match is found; the exact strategy whereby this determination is made will be covered in the balance of this chapter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525926047058.png&quot; alt=&quot;image&quot; /&gt;
We can add &lt;strong&gt;sentinels&lt;/strong&gt; at the end of each buffer.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (*forward++) {
	case eof: 
		if (forward is at end of first buffer) {
			reload second buffer;
			forward = beginning of second buffer;
		}
		else if (forward is at the end of second buffer) {
			reload first buffer;
			forward = beginning of first buffer;
		}
		else 
			terminate lexical analysis
		break;
	case for other characters;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-3-token-specification&quot;&gt;3 Token Specification&lt;/h3&gt;
&lt;p&gt;We can say lexical structure is a set of token classes. And thus we must say what set of strings is in a token class–&amp;gt; use regular language.&lt;/p&gt;

&lt;p&gt;An &lt;strong&gt;alphabet&lt;/strong&gt; is any finite set of symbols. 
A &lt;strong&gt;string&lt;/strong&gt; over an alphabet is a finite sequence o symbols drawn from the alphabet. 
A &lt;strong&gt;language&lt;/strong&gt; is any countable set of strings over some fixed alphabet. 
meaning function $L$ maps syntax to semantics. 
meaning is many to one.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;operations on language&lt;/strong&gt;
&lt;img src=&quot;/assets/images/1525926320045.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;heading-31-regular-expression&quot;&gt;3.1 Regular Expression&lt;/h4&gt;
&lt;p&gt;We are able to describe identifiers by giving names to sets of letters and digits and using the language operators union, concatenation, and closure. This process is so useful that a notation called &lt;strong&gt;regular expression&lt;/strong&gt; has come into common use for describing all the language that can be built from these operators applied to the symbols of some alphabet.&lt;br /&gt;
Here are the rules that define the regular expressions over some alphabet $\Sigma$ and the languages that those expressions denote. 
There are two rules that form the basis:&lt;/p&gt;

&lt;p&gt;(1) $\epsilon$ is a regular expression, and $L(\epsilon)$ is ${\epsilon}$, that is, the language whose sole member is empty string.&lt;/p&gt;

&lt;p&gt;(2) If $a$ is a symbol in $\Sigma$, then $a$ is a regular expression, and $L(a) = {a}$, that is, the language with one string, of length one, with $a$ in its one position.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/1525926883438.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525926900662.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;heading-32-extensions-of-regular-expressions&quot;&gt;3.2 Extensions of Regular Expressions&lt;/h4&gt;
&lt;p&gt;(1) One or more instances. &lt;code class=&quot;highlighter-rouge&quot;&gt;(r)+&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2) Zero or one instance. &lt;code class=&quot;highlighter-rouge&quot;&gt;r?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(3) Character classes &lt;code class=&quot;highlighter-rouge&quot;&gt;[abc]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-4-recognition-of-tokens&quot;&gt;4 Recognition of Tokens&lt;/h3&gt;
&lt;p&gt;Here is our example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stmt -&amp;gt; if expr then stmt
	 | if expr then stmt else stmt
	 |  $\epsilon$
expr -&amp;gt; term relop term
	 | term
term -&amp;gt; id
	 | number 
ws -&amp;gt; (blank | tab | newline)+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525928409876.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;heading-5-finite-automata&quot;&gt;5 Finite Automata&lt;/h3&gt;
&lt;p&gt;The heart of transition is the formalism known as &lt;strong&gt;finite automata&lt;/strong&gt;. 
Finite automata come in two flavors:&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Nondeterministic finite automata&lt;/strong&gt;(NFA) have no restrictions on the labels of their edges. A symbol can label several edges out of the same state, and $\epsilon$, the empty string, is a possible label.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Deterministic finite automata&lt;/strong&gt; (DFA) have, for each state, and for each symbol of its input alphabet exactly one edge with that symbol leaving the state.&lt;/p&gt;

&lt;p&gt;Both deterministic and nondeterministic finite automata are capable of recognizing the same language. In fact these language are exactly the same language, called the &lt;strong&gt;regular language&lt;/strong&gt;, that regular expressions can describe.&lt;/p&gt;
&lt;h4 id=&quot;heading-51-nfa&quot;&gt;5.1 NFA&lt;/h4&gt;
&lt;p&gt;NFA consists of :
(1) A finite set of states $S$&lt;/p&gt;

&lt;p&gt;(2) A set of input symbols $\Sigma$, the input alphabet. We assume that $\epsilon$, which stands for the empty string, is never a member of $\Sigma$&lt;/p&gt;

&lt;p&gt;(3) A transition function that gives, for each state, and for each symbol in $\Sigma \cup{\epsilon}$ a set of next states.&lt;/p&gt;

&lt;p&gt;(4) A state $s_0$ from $S$ that is distinguished as the start state(or initial state)&lt;/p&gt;

&lt;p&gt;(5) A set of states $F$, a subset of $S$, that is distinguished as the accepting states(or final states)&lt;/p&gt;

&lt;p&gt;An NFA &lt;strong&gt;accepts&lt;/strong&gt; input string $x$ iff there is some path in the transition graph from the start state to one of the &lt;strong&gt;accepting states&lt;/strong&gt;, such that the symbols along the path spell out $x$.&lt;/p&gt;
&lt;h4 id=&quot;heading-52-dfa&quot;&gt;5.2 DFA&lt;/h4&gt;
&lt;p&gt;A deterministic finite automata is a special case of an NFA where&lt;/p&gt;

&lt;p&gt;(1) There are no moves on input $\epsilon$&lt;/p&gt;

&lt;p&gt;(2) For each state $s$ and input symbol $a$, there is exactly one edge out of $s$ labeled $a$.&lt;/p&gt;

&lt;p&gt;Every regular expression and every NFA can be converted to a DFA accepting the same language, because it is the DFA that we really implement or simulate when building lexical analyzers.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Simulate a DFA
s = s_0;
c = nextChar();
while (c != eof) {
	s = move(s, c);
	c = nextChar();
}
if (s in Final_state) return &quot;yes&quot;;
else return &quot;no&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;heading-6-regular-expression---automata&quot;&gt;6 Regular Expression -&amp;gt; Automata&lt;/h3&gt;
&lt;h4 id=&quot;heading-61-nfa-dfa&quot;&gt;6.1 NFA-&amp;gt;DFA&lt;/h4&gt;
&lt;p&gt;The general idea behind the subset construction is that each state of the constructed DFA corresponds to a set of NFA states. After reading input $a_1a_2…a_n$, the DFA is in that state which corresponds to the set of states that NFA can reach, from its start state, following paths labeled $a_1a_2…a_n$. 
&lt;img src=&quot;/assets/images/1525974027615.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before reading the first input symbol, N can be in any of the states of $\epsilon-closure(s_0)$. For induction, suppose N can be in set of states $T$ after reading input string $x$. If it next reads input $a$, then $N$ can immediately go to any of the states in $move(T,a)$. However, after reading $a$, it may also make $\epsilon$ transitions. Thus $N$ could be in any state of $\epsilon-closure(move(T,a))$ after reading input $xa$. 
How to construct the set of $D$'s states, $Dstates$, and its transition function $Dtran$. 
Initially, $\epsilon-closure(s_0)$ is the only state in $Dstates$ and it is unmarked.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# construct Dstates and Dtran
while (there is an unmarked state T in Dstates) {
	mark T;
	for (each input symbol a) {
		U  = epsilon-closure(move(T, a));
		if (U is not in Dstates)
			add U as an unmarked state to Dstates;
		Dtran[T,a] = U;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# compute epsilon closure for T
push all states of T onto stack;
initialize epsilon-closure(T) to T;
while (stack is not empty) {
	pop t off the stack;
	for (each state u with an edge from t to u labeled epsilon) {
		if (u is not in epsilon-closure(T)) {
			add u to epsilon-closure(T);
			push u onto stack;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525975686530.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For line 1 and line 4 we can implement a function &lt;code class=&quot;highlighter-rouge&quot;&gt;addState(s)&lt;/code&gt;. This function pushes state $s$ onto &lt;code class=&quot;highlighter-rouge&quot;&gt;newStates&lt;/code&gt;, sets &lt;code class=&quot;highlighter-rouge&quot;&gt;alreadyOn[s]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;, and calls itself recursively on the states in &lt;code class=&quot;highlighter-rouge&quot;&gt;move[s,epsilon]&lt;/code&gt; in order to further the computation of $\epsilon-closure(s)$&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addState(s) {
	push s onto newStates;
	alreadyOn[s] = True;
	for (t on move[s, epsilon])
		if (!alreadyOn(t))
			addState(t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For line 4&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (s on oldStates) {
	for (t on move[s,c]) 
		if (!alreadyOn[t])
			addState(t);
	pop s from oldStates;
}
for (s on newStates) {
	pop s from newStates;
	push s onto oldStates;
	alreadOn[s] = FALSE;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;heading-62-regular-expression---nfa&quot;&gt;6.2 Regular Expression -&amp;gt; NFA&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525976909215.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977147532.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977159550.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;/assets/images/1525977172727.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NFA properties:
(1) $N(r)$ has at most twice as many states as there are operators and operands in $r$. This bound follows the fact that each step of the algorithm creates at most two new states&lt;/p&gt;

&lt;p&gt;(2) $N(r)$ has one start state and one accepting state. The accepting state has no outgoing transitions, and the start has no incoming transitions.&lt;/p&gt;

&lt;p&gt;(3) Each state of $N(r)$ other than the accepting state has either one outgoing transition on a symbol in $\Sigma$ or two outgoing transitions, both on $\epsilon$.&lt;/p&gt;

&lt;h3 id=&quot;heading-7-design-for-a-lexical-generator&quot;&gt;7. Design for a Lexical Generator&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/1525981672518.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The program that serves as the lexical analyzer includes a fixed program that simulates an automaton. We need a single automation that will recognize lexemes matching any of the patterns in the program, so we combine  all the NFA's into one by introducing a new start state with $\epsilon$-transitions to each of the start states of the NFA's $N_i$.&lt;/p&gt;</content><author><name>Wang Wei</name></author><category term="Compiler" /><summary type="html">Lexical Analysis goal: identify each lexeme and return information on token 1 Lexical Analyzer Role (1) read input characters, group them into lexemes, and produce output a sequence of tokens</summary></entry></feed>
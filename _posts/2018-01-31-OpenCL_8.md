---
layout: post
title: "OpenCL notes_8 How to write an OpenCL wrapper"
description: "OpenCL notes_8 How to write an OpenCL wrapper"
categories: [OpenCL]
tags: [parallel, OpenCL]
redirect_from:
  - /2018/01/27/
---

## 1. An OpenCL wrapper
Have been working on `OpenCL` these days. Since the complexity of those "environment objects", I think it necessary to write a wrapper to include all necessary components when performing computation. 
My purpose is to write one matrix-matrix multiplication instance. The question is that if I put all `OpenCL` configurations in the matrix class, all instances of this matrix class will need to hold one copy of this class. So I think it appropriate to declare this config subclass `static`. 
But this is not the end, since if I declare one non-built-in class within one class, this `static` type should be defined outside of the class. 
## 2. Implementation
First, you need to wrap two functions for selecting platform and device. There are so many parameters and error check in `OpenCL` API, so I tried to simplify their numbers. 
```
	cl_platform_id choose_platform(const std::string& pltfrm_name);
	// offset is device's position in a vector<cl_device_id>
	// this function will call choose_mult_device and select one with offset
	cl_device_id choose_device(cl_platform_id platform, const std::string& devs_name, size_t offset);
	std::vector<cl_device_id> choose_mult_device(cl_platform_id, const std::string& device_type);
```
```
	cl_platform_id choose_platform(const std::string& pltfrm_name) {
		cl_uint platform_num = 0;
		cl_int err = clGetPlatformIDs(0, NULL, &platform_num);
		if (err < 0) {
			perror("query platform error\n");
		}
		std::vector<cl_platform_id> platforms(platform_num);
		err = clGetPlatformIDs(platform_num, &platforms[0], NULL);
		if (err < 0) {
			perror("get platform vector error\n");
		}
		cl_uint index = platform_num;
		// Query info for each devices and try to match pltfrm_name
		for (cl_uint i = 0; i < platform_num; i++)
		{
			size_t plt_name_len = 0;
			err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &plt_name_len);
			if (err < 0) {
				perror("cannot find platform\n");
			}
			std::vector<char> plt_name(plt_name_len);
			err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, plt_name_len,
				&plt_name[0], NULL);
			if (err < 0) {
				perror("cannot find platform\n");
			}
			if (std::string(&plt_name[0]).find(pltfrm_name) != std::string::npos)
			{
				printf("%s\n", &plt_name[0]);
				index = i;
			}
		}
		if (index >= platform_num) {
			perror("out of platform index\n");
			exit(1);
		}
		// may have truble
		return platforms[index];
	}
	std::vector<cl_device_id> choose_mult_device(cl_platform_id platform, const std::string& device_type) {
		cl_device_type type;
		if (device_type == "gpu" || device_type == "GPU") {
			type = CL_DEVICE_TYPE_GPU;
		} 
		else if (device_type == "cpu" || device_type == "CPU") {
			type = CL_DEVICE_TYPE_CPU;
		} 
		else {
			type = CL_DEVICE_TYPE_DEFAULT;
		}
		cl_uint device_num = 0;
		cl_int err = clGetDeviceIDs(platform, type, 0, 0, &device_num);
		if (err < 0) {
			perror("cannot find device");
		}
		std::vector<cl_device_id> devices(device_num);
		err = clGetDeviceIDs(platform, type, device_num, &devices[0], NULL);
		if (err < 0) {
			perror("cannot find device");
		}
		return devices;
	}
	cl_device_id choose_device(cl_platform_id platform, const std::string& devs_name, size_t offset) {
		std::vector<cl_device_id> devices = choose_mult_device(platform, devs_name);
		assert(offset < devices.size());
		return devices[offset];
	}
```
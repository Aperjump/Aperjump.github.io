---
layout: post
title: "Syntax Analysis"
description: "Syntax Analysis"
categories: [Compiler]
tags: [Compiler]
redirect_from:
  - /2018/05/19/
---
### 1. Intro
main topic: parsing methods
![image](/assets/images/1526745213800.png)

The parser constructs a parse tree and passes it to the rest of the compiler for further processing. 

Two parser methods: **top-down**(from root to leaves) and **bottom-up**(from leaves to root). The input for parser is scanned from left to right, one symbol at a time. 

**LL** and **LR** are expressive tools to describe most of the syntactic constructs in modern programming language. Parser implemented by hand often use **LL** grammars. Parser for larger class of **LR** grammars are usually constructed using automated tools. 

In practice, there are a number of tasks that might be conducted during parsing, such as collecting information about various tokens into the symbol table, performing type checking and other kind of semantic analysis and generating intermediate code. 

#### 1.1 Representative Grammars
![image](/assets/images/1526745812598.png)

This expression belongs to the class of **LR** grammars that are suitable for **bottom-up** parsing. This grammar can be adapted to handle additional operators and additional levels of precedence. However, it cannot be used for **top-down** parsing because it is left-recursive. 

> left-recursive ---> bottom up
> non-left-recursive ---> top down
#### 1.2 Error handling
Two strategies: **panic mode** and **phrase-level recovery**

(1) panic mode

On discovering an error, the parser discards input symbols one at a time until one of a designed set of **synchronizing token** is found. The synchronizing tokens are usually delimiters, such as semicolon or `}`. 

(2) phrase level recovery

On discovering an error, a parser may perform local correction on the remaining input; that is, it may replace a prefix of the remaining input by some string that allows the parser to continue. 

A typical local correction is to replace a comma by a semicolon, delete an extraneous semicolon, or insert a missing semicolon. 

### 2. Context-free Grammar

definition: A context-free grammar consists of terminals, nonterminals, a start symbol, and productions. 

(1) terminals are the basic symbols from which strings are formed. **We assume terminals are the first components of the tokens output by the lexical analyzer**. 

(2) nonterminals are syntactic variables that denote sets of strings. The sets of strings denoted by nonterminals help define the language generated by the grammar. Nonterminals impose a hierarchical structure on the language that is key to syntax analysis and translation. 

(3) start symbol is the set of strings it denotes is the language generated by the grammar. 

(4) production specify the manner in which terminals and nonterminals can be combined to form strings. 

`stmt -> if (expr) stmt else stmt`

If $\S \xrightarrow{*} \alpha$, where $S$ is the start symbol of a grammar $G$, we say that $\alpha$ is the **sentential form** of $G$. A sentential form may contain both terminals and nontermnials or even empty string. A **sentence** of $G$ is a sentential form with no nonterminals. The language generated by a grammar is its set of sentences. 

Thus a string of terminals $\omega$ is in $L(G)$, the language generated by $G$. iff $\omega$ is a sentence of $G$, or $S \xrightarrow{*} \omega$. A language that can be generated by a grammar is said to be **context-free** grammar. 

In **leftmost** derivations, the leftmost nonterminal in each sentential is always chosen. 
$\alpha \xrightarrow{lm} \beta$

In **rightmost** derivations, the rightmost nonterminal is always chosen. 
$\alpha \xrightarrow{rm} \beta$
#### 2.1 Parse Tree
A parse tree is a graphical representation of a derivation that filters out the order in which productions are applied to replace nonterminals. 
![image](/assets/images/1526748378855.png)

The leaves of a parse tree are labeled by nonterminals or terminals and read from left to right constitute a sentential form, called the **yield** or **frontier** of the tree. 

A parse tree ignores variations in the order in which symbols in sentential forms are replaced, there is a many-to-one relationship between derivations and parse tree. **we shall frequently parse by producing a leftmost or a rightmost derivation, since there is a one-to-one relationship between parse trees and either leftmost or rightmost derivations. 

#### 2.2 context-free grammar and regular expression

every constructs that can be described by a regular expression can be described  by a grammar, but not vice-versa. Every regular expression is a context-free grammar, but not vice-versa. 

### 3. Writing a Grammar
![image](/assets/images/1526750747974.png)

`if E1 then if E2 then S1 else S2`  has two parse trees. 
![image](/assets/images/1526750795078.png)

How to rewrite the grammar? 

idea: the statement between `then` and `else` must be matched. 
![image](/assets/images/1526762609720.png)

#### 3.1 eliminate left recursion 
A grammar is **left recursive** if it has a nonterminal $A$ such that there is a derivation $A \xrightarrow{+} A\alpha$. Here is one rule $A \xrightarrow{}A\alpha | \beta$ can be replaced by 

$$ A \rightarrow \beta A' \\
	 A' \rightarrow \alpha A' | \epsilon$$


Here we can change the rule in first section to this one (using the rule above)

$$ E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id$$


One general rule:

$$ A \rightarrow A\alpha_1 | A\alpha_2 | ...|A\alpha_m | \beta_1 | \beta_2 | ... | \beta_m $$

can be replaced by 

$$ A \rightarrow \beta_1A' | \beta_2A' | ... | \beta_n A' \\
	 A' \rightarrow \alpha_1A' | \alpha_2A' | ... | \alpha_m A' | \epsilon$$

#### 3.2 Left Factoring
Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive, top-down, parsing. When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen that we can make the right choice. 

For example: original rule:

$$ A \rightarrow \alpha \beta_1 | \alpha\beta_2 $$

can be left factor into 


$$ A \rightarrow \alpha A' \\
	 A \rightarrow \beta_1 | \beta_2 $$

![image](/assets/images/1526764155565.png)


### 4. Top-down parsing
Top-down parsing can be viewed as finding a **leftmost** derivation for an input string. 

main problem is find production for nonterminal A.

**recursive descent parsing**(requre backtracking). 

predictive parsing is a special case of recursive parsing, where no backtracing is required. Predictive parsing choose the correct A-production by looking ahead at the input a fixed number of symbols. 

$$ E \rightarrow T E' \\
	 E' \rightarrow +TE' \\
	 T \rightarrow FT' \\
	 T' \rightarrow *FT' \\ 
	 F \rightarrow  (E)|id$$


![image](/assets/images/1526764567285.png)

The class of grammars for which we can construct predictive parsers looking k symbols ahead in the input is called **LL(k)** class. 
#### 4.1 Recursive-Descent Parsing
```
void A() {
	Choose an A-production, A -> X1X2...Xk;
	for (i = 1 to k) {
		if (Xi is a nonterminal)
			call procedure Xi();
		else if (Xi equals the current input symbol a)
			advance the input to the next symbol;
		else
			catch error
	}
}
```
To allow backtracking, the code needs to be modified. First, we cannot choose a unique A-production in line (1), so we must try several productions. The failure in last `else` should return back to the first choice procedure. Only if there is no more A-production to try, there is a true error.

#### 4.2 FIRST and FOLLOW
$FIRST$ and $FOLLOW$ allow us to choose which production to apply, based on the next input symbol. 

Consider non-terminal A, production $A\rightarrow\alpha$, and we have input symbol $t$

$T[A,t] = \alpha$ in two cases($T$ is transition table): 

(1) if $\alpha \xrightarrow{*} t\beta$
- $\alpha$ can derive a $t$ in the first position
- we say that $t\in FIRST(\alpha)$

(2) if $A\rightarrow\alpha$ and $\alpha \xrightarrow{*} \epsilon$ and $S \xrightarrow{*}\beta At\delta$
- useful if stack has $A$, input is $t$, and $A$ cannot derive $t$
- In this case only option is to get rid of $A$ by deriving $\epsilon$
- we say that $t\in FOLLOW(A)$

$FIRST(\alpha)$, where $\alpha$ is any string of grammar symbols, to be the set of terminals that begin strings derived from $\alpha$. For example $A\xrightarrow{*}c\gamma$, so $c$ is in $FIRST(A)$. $FIRST(X)=\{t|X \xrightarrow{*}t\alpha\} \cup \{\epsilon | X \xrightarrow{*} \epsilon\}$
Algo:

(1) if $FIRST(t) = \{t\}$(t is terminal)

(2) $\epsilon \in FIRST(X)$ if $X\rightarrow\epsilon$ or if $X\rightarrow A_1...A_n$ and $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$

(3) $FIRST(\alpha) \subseteq FIRST(X)$ if $X\rightarrow A_1...A_n\alpha$ and  $\epsilon \in FIRST(A_i)$ for any $1 \leq i \leq n$


$FOLLOW(A)$ for nonterminal $A$ is the set of terminals $a$ that can appear immediately to the right of $A$ in some **sentential form**; that is, the set of terminals $a$ such that there exists a derivation of the form 
$S\xrightarrow{*}\alpha A\alpha\beta$
In addition, if $A$ can be the rightmost symbol in some sentential form, then $\$$ is in $FOLLOW(A)$; $\$$ reprents "endmark". $FOLLOW(X) = \{t|S\xrightarrow{*} \beta Xt\delta\}$

Intuition:

If $X\rightarrow AB$ then $FIRST(B) \subseteq FOLLOW(A)$ and $FOLLOW(X) \subseteq FOLLOW(B)$

If $B\xrightarrow{*}\epsilon$ then $FOLLOW(X) \subseteq FOLLOW(A)$
If $S$ is the start symbol then $\$ \in FOLLOW(S)$

Algo: 

(1) $\$\in FOLLOW(S)$

(2) $FIRST(\beta) - \{\epsilon\} \subseteq FOLLOW(X)$ for each production $A \rightarrow \alpha X\beta$($FOLLOW$ sets are just terminals, no empty set)

(3) $FOLLOW(A) \subseteq FOLLOW(X)$ for each production  $A \rightarrow \alpha X\beta$ where $\epsilon \in FIRST(\beta)$

#### 4.3 LL(1)
**no left-recursive or ambiguous grammar in LL(1)**

A grammar $G$ is LL(1) iff whenever $A\rightarrow\alpha|\beta$ are two distinct productions of $G$. 

![image](/assets/images/1526769704732.png)

Our goal here is to construct a parsing table $T$ for context-free grammar $G$

For each production $A\rightarrow \alpha$ in $G$ do:

- For each terminal $t \in FIRST(\alpha)$ do 
		$T[A,t] = \alpha$
- If $\epsilon \in FIRST(\alpha)$ for each $t \in FOLLOW(A)$ do
		$T[A,t] = \alpha$
- If $\epsilon \in FIRST(\alpha)$ and $\$ \in FOLLOW(A)$ do
		$T[A,\$] = \alpha$

**If any entry is multiply defined then $G$ is not LL(1). **
- not left factored
- left recursive
- ambiguous
...

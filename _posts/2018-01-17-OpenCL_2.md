---
layout: post
title: "OpenCL notes_2 data transfer and parition"
description: "OpenCL notes_2 data transfer and parition"
categories: [OpenCL]
tags: [parallel, OpenCL]
redirect_from:
  - /2018/01/17/
---

## 1. Kernel Args
```
cl_int clSetKernelArg ( cl_kernel kernel,
  cl_uint arg_index,
  size_t arg_size,
  const void *arg_value)
```
`index` is the position of argument in `__kernel` function. `arg_value` is the corresponding value. The argument data pointed to by `arg_value` is copied and the `arg_value` pointer can be reused by the application. 
If the argument is a memory object(complex data), the arg_value entry will be a pointer to the appropriate buffer, pipe, image or image array object. The memory object must be created with the context associated with the kernel object.
```
clSetKernelArg(proc, 0, sizeof(num), &num);
clSetKernelArg(proc, 0, sizeof(mem_obj), &mem_obj);
```
In OpenCL, memory objects are represented by `cl_mem` data structure, and they come in two types: **buffer objects** and **image objects**. 

## 2. Buffer Objects
Buffer objects package any type of data that doesn't involve images. 
```
cl_mem clCreateBuffer ( cl_context context,
  cl_mem_flags flags,
  size_t size,
  void *host_ptr,
  cl_int *errcode_ret)
```
This returns a `cl_mem` that wraps around the data identified by the `host_ptr` argument. 
-**Accessibility**: `CL_MEM_READ_WRITE`, `CL_MEM_WRITE_ONLY`, `CL_MEM_READ_ONLY`
-**Memory_Allocation**: `CL_MEM_USE_HOST_PTR`, `CL_MEM_ALLOC_HOST_PTR`, `CL_MEM_COPY_HOST_PTR`, `CL_MEM_HOST_WRITE_ONLY`
```
vec_buff = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR), sizeof(float) * 32, vec, &error);
```
If you're running host applications on a memory-limited system or on the same device that you're using to process kernels, set the `CL_MEM_USE_HOST_PTR` flag. 
If low memory isn't an issue but reliable data transfer is, set `CL_MEM_COPY_HOST_PTR`. 

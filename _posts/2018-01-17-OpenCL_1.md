---
layout: post
title: "OpenCL notes_1 host programming"
description: "OpenCL notes_1 host programming"
categories: [OpenCL]
tags: [parallel, OpenCL]
redirect_from:
  - /2018/01/17/
---
## 1. Host programming
My working device is Nvidia 1060 GPU, and I use CUDA v9.0. The test environment is Visual Studio 2017. Before starting talking about host programming, we need to congifure the development environment. 
Need to add three components:
(1) include path: `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\include`
(2) `OpenCL.lib` : `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.0\lib`
(3) `OpenCL.dll` : `C:\Program Files\NVIDIA Corporation\OpenCL`
### 1.1 Primitive types
```
\\CL\cl_platform.h
/* scalar types  */
typedef signed   __int8         cl_char;
typedef unsigned __int8         cl_uchar;
typedef signed   __int16        cl_short;
typedef unsigned __int16        cl_ushort;
typedef signed   __int32        cl_int;
typedef unsigned __int32        cl_uint;
typedef signed   __int64        cl_long;
typedef unsigned __int64        cl_ulong;

typedef unsigned __int16        cl_half;
typedef float                   cl_float;
typedef double                  cl_double;
```
Once you begin writing OpenCL code, the first thing is to initialize `cl_platform_id` data structure. Each `cl_platform_id` represents an OpenCL platform on the host. If you have one NVIDIA GPU and one AMD GPU, then you install two separate SDKs, then, you will get two different `cl_platform_id`. Reading the source code, this structure is only a 8-bytes pointer(x64).
```
\\CL\cl.h
typedef struct _cl_platform_id *    cl_platform_id;
typedef struct _cl_device_id *      cl_device_id;
typedef struct _cl_context *        cl_context;
typedef struct _cl_command_queue *  cl_command_queue;
```
### 2 Find Host
To initialize this structure, you need to call `cl_int clGetPlatformIDs(cl_unit, num_entries, cl_platform_id* platform, cl_uint* num_platforms)`
If return value is negative, this function fails.
`num_entries` is the maximum number of `cl_platform_id` which will be placed in `platform` array.
One good practice:
```
cl_platform_id* platforms;
cl_uint num_platforms;
clGetPlatformIDs(5, NULL, &num_platforms);
platforms = (cl_platform_id*) malloc(sizeof(cl_platform_id) * num_platforms);
clGetPlatformIDs(5, platforms, &num_platforms);
```
To get platform information, call
```
extern CL_API_ENTRY cl_int CL_API_CALL 
clGetPlatformInfo(cl_platform_id   /* platform */, 
                  cl_platform_info /* param_name */,
                  size_t           /* param_value_size */, 
                  void *           /* param_value */,
                  size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;
```
```
char pform_vendor[40];
clGetPlatformInfo(platforms[0], CL_PLATFORM_VENDOR, sizeof(pform_vendor), &pform_vendor, NULL);
```
## 3. Find devices
```
/* Device APIs */
extern CL_API_ENTRY cl_int CL_API_CALL
clGetDeviceIDs(cl_platform_id   /* platform */,
               cl_device_type   /* device_type */, 
               cl_uint          /* num_entries */, 
               cl_device_id *   /* devices */, 
               cl_uint *        /* num_devices */) CL_API_SUFFIX__VERSION_1_0;

extern CL_API_ENTRY cl_int CL_API_CALL
clGetDeviceInfo(cl_device_id    /* device */,
                cl_device_info  /* param_name */, 
                size_t          /* param_value_size */, 
                void *          /* param_value */,
                size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;
```

## 4. Device Management
In OpenCL, a **context** identifies a set of devices through **command queue**. 

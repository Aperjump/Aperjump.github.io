---
layout: post
title: "OpenCL notes_5 Event, Profiling, and Synchronization"
description: "OpenCL notes_5 Event, Profiling, and Synchronization"
categories: [OpenCL]
tags: [parallel, OpenCL]
redirect_from:
  - /2018/01/26/
---

In openCL, an event is a data structure that corresponds too an occurence. One event migh monitor the completion of a data transfer operation and another might monitor the execution of a kernel. 
- host notification
- command synchronization
- profiling

## 1. Host Notification
After the host enqueues a command, it has no controal over how the command will be processed, but it can receive notification when the command completes its execution. --> `cl_event`
For example, when the data transfer is complete, you may want the host application to respond by processing the data. 
You need to assocaite the event with the data transfer command. Then you need to associate the event with a function to be called on the host when the transfer command finishes. -->`callback function`
```
cl_event ev;
clEnqueueTask(queue, kernel, 0, NULL, &ev);
cl_int clSetEventCallback(cl_event event, cl_int callback_type, void (CL_CALLBACK *func_name) (cl_event, cl_int status, void *data), void* data);
```
The second arg `callback_type` identifies the type of command status you're interested in monitoring. `CL_COMPLETE`. 
```
clsetEventCallback(ev, CL_COMPLETE, &process, NULL);
void CL_CALLBACK func_name(cl_event event, cl_int status, void* data);
```
It's important to remember that `clSetEventCallback` must be called **after** the command enqueueing functions, else you will receive a segmentation fault. 
```
/* Enqueue kernel */
err = clEnqueueTask(queue, kernel, 0, NULL, &kernel_event);
if(err < 0) {
  perror("Couldn't enqueue the kernel");
  exit(1);   
}

/* Read the buffer */
err = clEnqueueReadBuffer(queue, data_buffer, CL_FALSE, 0, 
  sizeof(data), &data, 0, NULL, &read_event);
if(err < 0) {
  perror("Couldn't read the buffer");
  exit(1);   
}

/* Set event handling routines */
kernel_msg = "The kernel finished successfully.\n\0";
err = clSetEventCallback(kernel_event, CL_COMPLETE, 
     &kernel_complete, kernel_msg);
if(err < 0) {
  perror("Couldn't set callback for event");
  exit(1);   
}
clSetEventCallback(read_event, CL_COMPLETE, &read_complete, data);
```

## 2. Command Sync Events
command queue executes commands in order, but when dispatch different command queue, there will be no order guarantee. 
You can force one or more commands to wait until a set of events have completed. These events are called `wait list`
### 2.1 Wait list and command events
If you set the last argument of an enqueuing function to point to a `cl_event`, that event will be assocaited with the enqueued command. --> **command event**. 
Every OpenCL command has a wait list made of `cl_event` structures. If a command's waitlist is NULL, it can start executing as soon as it reaches the end of the command queue. If the command's wait list isn't NULL, then for every `cl_event` in the list, the command must halt until the event's corresponding occurrences has completed. 
```
//cl_uint num_events --> num of cl_event in the command's wait list
//const cl_event *wait_list -> pointer to the cl_event in the wait list
cl_event kernel_event[2];
clEnqueueTask(queue_a, kernel_a, 0, NULL, &kernel_event[0]);
clEnqueueTask(queue_b, kernel_b, 0, NULL, &kernel_event[1]);
clEnqueueTask(queue_c, kernel_c, 2, kernel_event, NULL);
```

### 2.2 user events
If an event is associate with an occurence within a host application, it's **user event**. 
Command events correspond to commands executing on the device, but but a user event is generated by the host application. 
```
cl_event clCreateUserEvent(cl_context context, cl_int *err);
```
If you add a user event to a command's wait list, theexecution of the command wait halt until the host application updates the event's status. This is accompolished by calling `clSetUserEventStatus` function. 

### 2.3 Marker command
`clEnqueueMarker` function enqueues a command called a **marker command** and associates an event with the execution of every command preceding it. 
```
cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event*event);
```
```
void CL_CALLBACK process(cl_event event, cl_int status, void* data) {
	...
}
int main() {
	cl_event ev;
	cl_int clSetEventCallback(ev, CL_COMPLETE, &process, NULL);
	cl_int clEnqueueMarker(cl_command_queue, ev);
}
```
### 2.4 Wait Command
**wait command** tells the command queue not to execute any following commands until the events in its wait list have reached a completed state. 
```
cl_nt clEnqueueWaitForEvents(cl_command_queue queue, cl_int num_events, const cl_event *wait_list);
```

```
cl_event e;
e = clCreateUserEvent(context, &err);
clEnqueueWaitForEvents(queue, 1, &e);
clSetUserEventStatus(e, CL_SUCCESS);
```
### 2.5 Barrier Command 
`clEnqueueBarrier` prevent later commands on the queue from executing. It enqueues a command called a **barrier command**. This forces following commands to stall until preceding commands have completed their execution. 
```
cl_int clEnqueueBarrier(cl_command_queue queue);
```

## 3. Profiling Events
### 3.1 Configure command profiling
Three steps:
1. Set the `CL_QUEUE_PROFILING_ENABLE` flag when you create a command queue with `clCreateCommandQueue`.
2. Associate a `cl_event` with the command you want to profile. 
3. After the command completes its executing, call `clGetEventProfilingInfo` to access the `cl_event` and obtain information about the command's timing. 

```
cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param, 
	size_t param_value_size, void* param_value, size_t* param_value_size_ret);
```
```
cl_event timing_event;
cl_ulong time_start, time_end, read_time;
queue = clCreateCommandQueue(context, device,
CL_QUEUE_PROFILING_ENABLE, NULL);
clEnqueueReadBuffer(queue, data_buffer, TRUE, 0,
sizeof(data), data, 0, NULL, &timing_event);
clGetEventProfilingInfo(timing_event, CL_PROFILING_COMMAND_START,
sizeof(time_start), &time_start, NULL);
clGetEventProfilingInfo(timing_event, CL_PROFILING_COMMAND_END,
sizeof(time_end), &time_end, NULL);
read_time = time_end - time_start;
```

## 4. Work-item Synchronization
